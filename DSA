#include <bits/stdc++.h>

#include <iostream>

3ï¸âƒ£ Binary Search using STL
bool found = binary_search(a.begin(), a.end(), target);

__builtin_popcount(x) gives the number of 1-bits in x.
stoi() 
stoll()
sqrt(n)
pow(n, 2);
sort(arr, arr + n);
to_string(val3)
n = abs(n);          // handle negative numbers
long long val1 = stoll(first);
string third = to_string(val3);
reverse(s.begin(), s.end());
string second = num.substr(index, length);
s.erase(s.size() - 5);  // removes last 5 characters

ğŸ“Š Bonus: Get Max + Index
auto it = max_element(v.begin(), v.end());
int mx = *it;
int index = it - v.begin();

int mx = *max_element(v.begin(), v.end());

sort(jobs.rbegin(), jobs.rend());   // descending

int high = accumulate(jobs.begin(), jobs.end(), 0);

int gcdVal = __gcd(nums1, nums2);

4ï¸âƒ£ Using STL (min_element, max_element)
int largest = *max_element(arr, arr + n);
int smallest = *min_element(arr, arr + n);


vector<vector<int>> score;
score.assign(m, vector<int>(m, 0));



for (string num : nums)   integers.insert(stoi(num, 0, 2));

âœ” stoi(num, 0, 2) converts a binary string to an integer
Example: "11" â†’ 3


string ans = bitset<16>(num).to_string();
âœ” Converts num into a 16-bit binary string

Example: num = 2 => "0000000000000010"

return ans.substr(16 - n);
We only need the last n bits

Example: n = 2
"0000000000000010".substr(14) â†’ "10"



2ï¸âƒ£ Using Bitwise AND Operator (Faster)
bool isEven(int n) {
    return (n & 1) == 0;
}

bool isOdd(int n) {
    return (n & 1) == 1;
}

ğŸ’¡ Explanation:
n & 1 checks the least significant bit
LSB 0 â†’ Even, LSB 1 â†’ Odd




2ï¸âƒ£ Optimized Method (Up to âˆšn) â­ Best for Interviews
bool isPrime(int n) {
    if (n <= 1) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;

    for (int i = 3; i * i <= n; i += 2) {
        if (n % i == 0)
            return false;
    }
    return true;
}

â±ï¸ Time: O(âˆšn)
ğŸ“¦ Space: O(1)




void sieve(int n) {
    vector<bool> isPrime(n + 1, true);

    isPrime[0] = false;
    isPrime[1] = false;

    for (int i = 2; i * i <= n; i++) { // ********* till i*i <= n ************* 
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) { // ********* start j from i*i *************
                isPrime[j] = false;
            }
        }
    }

    for (int i = 2; i <= n; i++) {
        if (isPrime[i])
            cout << i << " ";
    }
}




2ï¸âƒ£ Using Euclidean Algorithm (Most Preferred)

Recursive Approach:
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

Iterative Approach:
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
âœ… Time Complexity: O(log min(a, b))
âœ… Space Complexity: O(1) (iterative), O(log n) (recursive)


3ï¸âƒ£ Using STL Function (C++17+)
#include <numeric> // for std::gcd
int main() {
    int a = 12, b = 18;
    cout << gcd(a, b); // Output: 6
}


4ï¸âƒ£ LCM Using GCD
Relation: LCM(a, b) * GCD(a, b) = a * b



swap(a, b);

2ï¸âƒ£ Swap no.s Without Using a Temporary Variable (Using Arithmetic)
a = a + b;
b = a - b;
a = a - b;

3ï¸âƒ£ Using XOR Bitwise Operator (No Temp, No Overflow)
a = a ^ b;
b = a ^ b;
a = a ^ b;



ğŸ”¢ Armstrong Number => A number is called an Armstrong number (also known as a Narcissistic number) if:
sum of (each digit)^number of digits = number itself
| Number | Explanation                    |
| ------ | ------------------------------ |
| 153    | (1^3 + 5^3 + 3^3 = 153)        |
| 370    | (3^3 + 7^3 + 0^3 = 370)        |
| 9474   | (9^4 + 4^4 + 7^4 + 4^4 = 9474) |

âš ï¸ Common Interview Mistakes
âŒ Assuming Armstrong numbers are only 3-digit

ğŸ¯ One-Line Interview Answer
â€œAn Armstrong number is equal to the sum of its digits raised to the power of the number of digits.â€




2ï¸âƒ£ Dutch National Flag Algorithm (Optimal â€“ Single Pass)
void sort012(int arr[], int n) {
    int low = 0, mid = 0, high = n - 1;

    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low], arr[mid]);
            low++;
            mid++;
        } else if (arr[mid] == 1) {
            mid++;
        } else { // arr[mid] == 2
            swap(arr[mid], arr[high]);
            high--;
        }
    }
}

âœ… Time: O(n)
âœ… Space: O(1)
âœ… In-place and single pass (most preferred for interviews)





ğŸ”¢ Find Missing & Repeating Number
ğŸ“Œ Problem => Given an array of size n containing numbers from 1 to n: One number is missing, One number is repeating
Example
Input:  [4, 3, 6, 2, 1, 1]
Output: Repeating = 1, Missing = 5

1ï¸âƒ£ Using Mathematical Equations (Most Asked)
ğŸ’¡ Idea
Let:
S = sum(1..n) => n * (n + 1) / 2;
S2 = sum of squares(1..n) => n * (n + 1) * (2*n + 1) / 6;
s = sum of array
s2 = sum of squares of array

Then:
missing - repeating = S - s
missingÂ² - repeatingÂ² = S2 - s2

âœ… Code
void findMissingRepeating(int arr[], int n) {
    long long S = (long long)n * (n + 1) / 2;
    long long S2 = (long long)n * (n + 1) * (2*n + 1) / 6;

    long long s = 0, s2 = 0;
    for (int i = 0; i < n; i++) {
        s += arr[i];
        s2 += (long long)arr[i] * arr[i];
    }

    long long diff = S - s;            // M - R
    long long diff2 = S2 - s2;          // MÂ² - RÂ²

    long long sum = diff2 / diff;       // M + R ************* v.v.v.imp *********************

    long long missing = (diff + sum) / 2;    // ******************
    long long repeating = sum - missing;    // ******************

    cout << "Repeating = " << repeating << endl;
    cout << "Missing = " << missing << endl;
}

âœ… Time: O(n)
âœ… Space: O(1)


2ï¸âƒ£ Using XOR (Most Optimal & Clean)
ğŸ’¡ Idea
XOR all array elements and numbers 1..n
Get missing ^ repeating

Separate using rightmost set bit

âœ… Code
void findMissingRepeating(int arr[], int n) {
    int xr = 0;
    for (int i = 0; i < n; i++) {
        xr ^= arr[i];
        xr ^= (i + 1);
    }

    int setBit = xr & -xr; // ****************** v.v.v.v.imp *******************************
    int x = 0, y = 0;

    for (int i = 0; i < n; i++) {
        if (arr[i] & setBit) x ^= arr[i];
        else y ^= arr[i];

        if ((i + 1) & setBit) x ^= (i + 1);
        else y ^= (i + 1);
    }

    for (int i = 0; i < n; i++) {
        if (arr[i] == x) {
            cout << "Repeating = " << x << "\nMissing = " << y;
            return;
        }
    }
    cout << "Repeating = " << y << "\nMissing = " << x;
}

âœ… Time: O(n)
âœ… Space: O(1)
ğŸ”¥ Most preferred in interviews




ğŸ”¥ Maximum Sum Subarray (Kadaneâ€™s Algorithm)
ğŸ“Œ Problem : Given an integer array, find the contiguous subarray with the maximum sum.
Example
Input:  [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Output: 6
Subarray: [4, -1, 2, 1]

âœ… Kadaneâ€™s Algorithm (Clean & Simple)
int maxSubArraySum(int arr[], int n) {
    int currentSum = arr[0]; // ************ v.v.v.imp ************
    int maxSum = arr[0];  // ************ v.v.v.imp ************

    for (int i = 1; i < n; i++) {
        currentSum = max(arr[i], currentSum + arr[i]);  // ************ v.v.v.imp ************
        maxSum = max(maxSum, currentSum);
    }
    return maxSum;
}



âœ… Simplest Kadaneâ€™s Algorithm (MAX SUM ONLY)
int maxSubArraySum(int arr[], int n) {
    int currentSum = 0;
    int maxSum = INT_MIN;

    for (int i = 0; i < n; i++) {
        currentSum += arr[i];

        if (currentSum > maxSum)
            maxSum = currentSum;

        if (currentSum < 0)
            currentSum = 0;
    }
    return maxSum;
}



âœ… Subarray With Given Sum
Works for non-negative numbers

bool subarrayWithSum(int arr[], int n, int target) {
    int start = 0, end = 0;
    int sum = 0;

    while (end < n) {
        sum += arr[end];

        while (sum > target && start <= end) {
            sum -= arr[start];
            start++;
        }

        if (sum == target) {
            cout << "Subarray found from index "
                 << start << " to " << end << endl;
            return true;
        }
        end++;
    }
    return false;
}

ğŸ§  Simple Explanation
end expands the window
start shrinks the window if sum exceeds target
Check sum at every step



âœ… CASE 2: Array WITH NEGATIVE numbers
ğŸ‘‰ Use Prefix Sum + HashMap
ğŸ’¡ Idea => If: prefixSum[i] - prefixSum[j] = target

Then subarray (j+1 to i) has given sum.
ğŸ”¹ Simple C++ Code (Works for ALL integers)
bool subarrayWithSum(int arr[], int n, int target) {
    unordered_map<int, int> mp;
    int sum = 0;

    for (int i = 0; i < n; i++) {
        sum += arr[i];

        if (sum == target) {
            cout << "Subarray found from index 0 to " << i << endl;
            return true;
        }

        if (mp.find(sum - target) != mp.end()) {
            cout << "Subarray found from index "
                 << mp[sum - target] + 1 << " to " << i << endl;
            return true;
        }

        mp[sum] = i;
    }
    return false;
}


1) Binary search

Binary Search is a search algorithm used on sorted arrays (or ranges) to find the position of a target value.
It repeatedly divides the search interval in half. (divide ad conquer algorithm)

Precondition: Array must be sorted.

| Case    | Time     | Space |
| ------- | -------- | ----- |
| Best    | O(1)     | O(1)  |
| Average | O(log n) | O(1)  |	
| Worst   | O(log n) | O(1)  |

â­ Interview Tips
Always mention array must be sorted
Use mid = low + (high - low) / 2 (avoid overflow)
Binary Search is widely used in:
- Lower/Upper Bound
- Search Space Optimization
- Competitive Programming


2) stack

A stack is a linear data structure that follows the LIFO (Last In First Out) principle â€” the last element inserted is the first to be removed.
Examples:
Stack of plates,Undo feature in editors,Browser back button,Recursion call stack

| Operation     | Description / Use                                      | Time Complexity |
|---------------|--------------------------------------------------------|-----------------|
| push(x)       | Add element x to the top of the stack                  | O(1)            |
| pop()         | Remove the top element                                 | O(1)            |
| peek() / top()| Get the top element without removing it                | O(1)            |
| isEmpty()     | Check if the stack is empty                            | O(1)            |
| size()        | Return the number of elements in the stack             | O(1)            |

Monotonic Stack -> A monotonic stack is a stack that maintains elements in increasing or decreasing order.

Stack in Recursion -> During recursion, function calls are stored in the call stack. Each recursive call is pushed onto the stack, 
and once the function completes, it's popped off. This allows the program to return to the correct previous state.



******************  Sorting  ************************

| Algorithm       | Idea (Concept)                                      | Best Case  | Avg Case   | Worst Case | Space    | Stable  | In-place  | Best Use Case                                 |
| --------------- | --------------------------------------------------- | ---------- | ---------- | ---------- | -------- | ------  | --------  | --------------------------------------------- |
| **Bubble Sort** | Repeatedly swap adjacent elements if out of order   | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     | âœ… Yes  | âœ… Yes    | Small / nearly sorted arrays, teaching basics |
| **Selection**   | Select min element, place at beginning              | O(nÂ²)      | O(nÂ²)      | O(nÂ²)      | O(1)     | âŒ No   | âœ… Yes    | Few swaps needed, simple logic                |
| **Insertion**   | Insert element into correct position in sorted part | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     | âœ… Yes  | âœ… Yes    | Nearly sorted or small arrays                 |
| **Quick Sort**  | Partition around pivot, sort subarrays              | O(n log n) | O(n log n) | O(nÂ²)      | O(log n) | âŒ No   | âœ… Yes    | Large datasets, fastest in practice           |
| **Merge Sort**  | Divide array, sort halves, merge                    | O(n log n) | O(n log n) | O(n log n) | O(n)     | âœ… Yes  | âŒ No     | Linked lists, stability required              |
| **Heap Sort**   | Build max heap, extract max, heapify                | O(n log n) | O(n log n) | O(n log n) | O(1)     | âŒ No   | âœ… Yes    | Guaranteed O(n log n) in-place sort           |


ğŸ” Key Definitions (Interview Must-Know)
ğŸ”¹ Adaptive : A sorting algorithm is adaptive if it takes less time for partially sorted input.
âœ” Example: Insertion Sort performs in O(n) for nearly sorted arrays.

ğŸ”¹ Stable : A sorting algorithm is stable if it preserves the relative order of equal elements.


| Sorting Algorithm  | Adaptive  | Stable   | In-Place  | Time Complexity (Avg) |
| ------------------ | --------  | -------  | --------  | --------------------- |
| **Bubble Sort**    | âœ… Yes    | âœ… Yes   | âœ… Yes    | O(nÂ²)                 |
| **Selection Sort** | âŒ No     | âŒ No    | âœ… Yes    | O(nÂ²)                 |
| **Insertion Sort** | âœ… Yes    | âœ… Yes   | âœ… Yes    | O(nÂ²)                 |
| **Merge Sort**     | âŒ No     | âœ… Yes   | âŒ No     | O(n log n)            |
| **Quick Sort**     | âŒ No     | âŒ No    | âœ… Yes    | O(n log n)            |
| **Heap Sort**      | âŒ No     | âŒ No    | âœ… Yes    | O(n log n)            |



Quick Memory Hooks
Stable Sorts: BIM â†’ Bubble, Insertion, Merge
In-place: All except Merge
Guaranteed O(n log n): Merge, Heap
Best for large data: Quick (fast), Merge (stable)
Best for nearly sorted: Insertion

Idea keywords:
Bubble â†’ Swap Adjacent (â€œbubbleâ€ largest to the end).
Selection â†’ Select Min  (Find minimum element in unsorted part, place it at beginning.)
Insertion â†’ Insert in Sorted ( Insert each element into its correct position in the sorted part.)
Quick â†’ Pivot Partition (Choose pivot, partition array into < pivot and > pivot, recursively sort.)
Merge â†’ Divide & Merge ( Divide array into halves, sort each half, merge sorted halves.)
Heap â†’ Heapify & Extract (Build max heap, repeatedly extract max element, heapify remaining.)


In C++, `std::sort` (from `<algorithm>`) uses a **hybrid sorting algorithm called IntroSort**.
It works like this:
* **Starts with Quicksort** for fast average performance.
* If recursion depth becomes too large (to avoid worst-case O(nÂ²)), it **switches to Heapsort** to ensure O(n log n) worst-case time.
* For very small subarrays, it uses **Insertion sort** for better efficiency.
* Best case: O(n log n)
* Average case: O(n log n)
* Worst case: O(n log n)

sort(nums.begin(), nums.end(), greater<int>());


ğŸ“Œ What is IntroSort?
IntroSort starts with Quick Sort, but if recursion goes too deep (indicating bad pivot choices), it switches to Heap Sort.
For small subarrays, it uses Insertion Sort.
ğŸ‘‰ This avoids Quick Sortâ€™s O(nÂ²) worst case.

ğŸ§© Working Flow (Simple)
Start Quick Sort
   â†“
If recursion depth too high
   â†“
Switch to Heap Sort
   â†“
For small subarrays â†’ Insertion Sort



void insertionSort(vector<int>& a) {
    int n = a.size();
    for (int i = 1; i < n; i++) {
        int key = a[i], j = i - 1;
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = key;
    }
}



void merge(vector<int>& a, int l, int m, int r) {
    vector<int> L(a.begin() + l, a.begin() + m + 1); // *********** v.v.v.imp ************************
    vector<int> R(a.begin() + m + 1, a.begin() + r + 1); // *********** v.v.v.imp ************************

    int i = 0, j = 0, k = l;
    while (i < L.size() && j < R.size())
        a[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];

    while (i < L.size()) a[k++] = L[i++];
    while (j < R.size()) a[k++] = R[j++];
}

void mergeSort(vector<int>& a, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(a, l, m);
        mergeSort(a, m + 1, r);
        merge(a, l, m, r);
    }
}



int partition(vector<int>& a, int low, int high) {
    int pivot = a[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (a[j] < pivot)
            swap(a[++i], a[j]);
    }
    swap(a[i + 1], a[high]);
    return i + 1;
}

void quickSort(vector<int>& a, int low, int high) {
    if (low < high) {
        int pi = partition(a, low, high);
        quickSort(a, low, pi - 1);
        quickSort(a, pi + 1, high);
    }
}




void heapify(vector<int>& a, int n, int i) {
    int largest = i;
    int l = 2 * i + 1, r = 2 * i + 2;

    if (l < n && a[l] > a[largest]) largest = l;
    if (r < n && a[r] > a[largest]) largest = r;

    if (largest != i) {
        swap(a[i], a[largest]);
        heapify(a, n, largest);
    }
}

void heapSort(vector<int>& a) {
    int n = a.size();
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(a, n, i);

    for (int i = n - 1; i > 0; i--) {
        swap(a[0], a[i]);
        heapify(a, i, 0);
    }
}



************************************* Sliding window and 2 pointer ********************************************
1.Fixed-size window
  Window size k is constant.
  Example: Max sum of subarray of size k.

2.Variable-size window ( longest subarray / substring where <condition> )
  Window expands/contracts until a condition is met.
  Example: Longest subarray where sum <= k.

3. No. of subarray where <condition> 
  using pattern 2 ==>  
  (No. of subarray where  sum = k)  = (No. of subarray where  sum <= k) - (No. of subarray where  sum <= (k-1))
  ans = x-y

4.Shortest / Minimum window <condition>



