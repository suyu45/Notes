What is JavaScript?
JavaScript is a high-level, interpreted, dynamically typed programming language mainly used to create interactive and dynamic content on websites.
It runs primarily in the browser (using JavaScript engines like V8) and also on the server using environments like Node.js.

Common uses:
Form validation
Dynamic UI updates
API calls (AJAX / Fetch)
Frontend frameworks (React, Angular, Vue)
Backend development (Node.js)
Mobile & desktop apps


| Feature           | JavaScript                           | Java                                 |
| ----------------- | ------------------------------------ | ------------------------------------ |
| Language type     | Scripting language                   | Object-Oriented Programming language |
| Typing            | Dynamically typed                    | Statically typed                     |
| Compilation       | Interpreted / JIT compiled           | Compiled to bytecode                 |
| Platform          | Browser & Server (Node.js)           | JVM (Java Virtual Machine)           |
| Syntax            | Lightweight & flexible               | Verbose & strict                     |
| OOP               | Prototype-based                      | Class-based                          |
| Execution         | Single-threaded (event loop)         | Multi-threaded                       |
| Use cases         | Web development (frontend + backend) | Enterprise, Android, backend systems |
| File extension    | `.js`                                | `.java`                              |
| Memory management | Automatic (GC)                       | Automatic (GC)                       |


Key Differences Explained (Interview Friendly)

1. Typing

JavaScript determines variable type at runtime
let x = 10;
x = "hello";

Java requires type declaration at compile time
int x = 10;



Detailed Explanation (Easy to Understand)
Originally, JavaScript was considered an interpreted language, but modern JavaScript engines (like V8, SpiderMonkey, Chakra) use Just-In-Time (JIT) compilation.

Why Not Fully Compiled Like C/C++?
JavaScript is dynamically typed
Code can change at runtime


Why is JavaScript Single-Threaded?
Short interview answer:
üëâ JavaScript is single-threaded to keep the language simple, predictable, and safe when interacting with the DOM.

Detailed Explanation (Interview-Ready)
1. To Avoid DOM Conflicts (Main Reason ‚≠ê)
JavaScript was designed mainly for browsers, where it interacts with the DOM (Document Object Model).

If multiple threads modified the DOM at the same time:
Race conditions would occur
UI could break or become inconsistent
Complex locking mechanisms would be required

üëâ Single thread ensures only one task modifies the DOM at a time.



1. var, let, const ‚Äì Overview
| Feature       | `var`                            | `let`         | `const`       |
| ------------- | -------------------------------- | ------------- | ------------- |
| Scope         | Function-scoped                  | Block-scoped  | Block-scoped  |
| Hoisting      | Yes (initialized as `undefined`) | Yes (TDZ)     | Yes (TDZ)     |
| Reassignment  | Allowed                          | Allowed       | ‚ùå Not allowed |
| Redeclaration | Allowed                          | ‚ùå Not allowed | ‚ùå Not allowed |
| Introduced in | ES5                              | ES6           | ES6           |

2. Scope
var ‚Äì Function Scope
function test() {
  var x = 10;
}
console.log(x); // ‚ùå Error (outside function)

But inside blocks:
if (true) {
  var y = 20;
}
console.log(y); // ‚úÖ 20


let ‚Äì Block Scope
if (true) {
  let a = 10;
}
console.log(a); // ‚ùå Error


const ‚Äì Block Scope
if (true) {
  const b = 30;
}
console.log(b); // ‚ùå Error


3. Hoisting ‚≠ê (Very Important)
var Hoisting
console.log(x); // undefined
var x = 10;

Reason:
var x is hoisted and initialized as undefined.

let & const Hoisting (TDZ) Temporal Dead Zone
console.log(y); // ‚ùå ReferenceError
let y = 10;

Variables are hoisted But not initialized

Exist in Temporal Dead Zone (TDZ) until declaration


4. Reassignment
var
var x = 10;
x = 20; // ‚úÖ allowed

let
let y = 10;
y = 20; // ‚úÖ allowed

const
const z = 10;
z = 20; // ‚ùå Error

5. const with Objects & Arrays ‚ö†Ô∏è (Tricky Question)
const obj = { name: "JS" };
obj.name = "JavaScript"; // ‚úÖ allowed
obj = {}; // ‚ùå Error

üëâ const prevents reassignment, not mutation.

6. Redeclaration
var a = 10;
var a = 20; // ‚úÖ allowed

let b = 10;
let b = 20; // ‚ùå Error

const c = 10;
const c = 20; // ‚ùå Error

7. Best Practices (Interview Tip üí°)
Use const by default
Use let when reassignment is needed
Avoid var (unless legacy code)

One-Line Interview Answer ‚≠ê
var is function-scoped and hoisted with undefined, while let and const are block-scoped, hoisted in the Temporal Dead Zone, and const does not allow reassignment.

Common Interview Output Question
console.log(a); ‚ùå ReferenceError (TDZ)
let a = 10;


1. What is Temporal Dead Zone?
Definition (simple):
üëâ TDZ is the time between the start of a block and the actual declaration of a let or const variable, during which the variable exists but cannot be accessed.

Accessing it in this period causes a ReferenceError.

2. Why TDZ Exists? (Very Important ‚≠ê)
TDZ was introduced with let and const to:
Prevent using variables before declaration
Catch bugs early
Enforce better coding practices
Make code behavior more predictable


1. What is Hoisting?
Definition:
üëâ Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top of their scope during the memory creation phase.
Happens before code execution
Affects variables and functions

| Feature         | Hoisting                         | TDZ                    |
| --------------- | -------------------------------- | ---------------------- |
| What it is      | JS mechanism                     | Safety restriction     |
| When it happens | Memory creation phase            | Runtime period         |
| Applies to      | `var`, `let`, `const`, functions | `let` and `const` only |
| Error thrown    | Usually none                     | ReferenceError         |
| Purpose         | Allocate memory                  | Prevent early access   |


4. Hoisting Behavior by Keyword

var
console.log(a); // undefined
var a = 10;

Hoisted
Initialized as undefined
‚ùå No TDZ


let
console.log(b); // ReferenceError
let b = 10;

Hoisted
‚ùå Not initialized
‚úÖ TDZ applies


5. Visual Timeline (Important üî•)
var
Hoisted ‚Üí initialized (undefined) ‚Üí assigned value

let / const
Hoisted ‚Üí TDZ ‚Üí initialized ‚Üí usable


10. One-Line Interview Answer ‚≠ê
Hoisting allocates memory for variables before execution, while TDZ is a restriction period for let and const where accessing them before initialization causes an error.

11. Interview Tip üí°
If asked: ‚ÄúAre let and const hoisted?‚Äù
Say: Yes, they are hoisted but kept in the Temporal Dead Zone until initialized.



2. Primitive Data Types ‚≠ê (Most Asked)
Primitive types store single values and are immutable.
List of Primitive Data Types: string, number, boolean, undefined, null, symbol, bigint

3. Non-Primitive Data Types
Non-primitive types store collections of values and are mutable.
object, array, function, date, ( map and set (internally objects) )

| Feature    | Primitive    | Non-Primitive             |
| ---------- | ------------ | ------------------------- |
| Stores     | Single value | Multiple / complex values |
| Stored by  | Value        | Reference                 |
| Mutable    | ‚ùå No         | ‚úÖ Yes                     |
| Memory     | Stack        | Heap                      |
| Comparison | By value     | By reference              |

3Ô∏è‚É£ boolean : Represents logical values.

let isLoggedIn = true;
Falsy values: false, 0, "", null, undefined, NaN

4Ô∏è‚É£ undefined : A variable declared but not assigned a value.

let a;
console.log(a); // undefined

Default value assigned by JS


5Ô∏è‚É£ null ‚≠ê (Very Tricky) : Represents intentional absence of value.

let data = null;

‚ö†Ô∏è Interview trap:
typeof null; // "object" (bug in JS)


6Ô∏è‚É£ symbol (ES6) : Represents unique and immutable values.

let id = Symbol("id");
let id2 = Symbol("id");
id === id2; // false

Used for:
Unique object keys
Avoiding naming conflicts


7Ô∏è‚É£ bigint (ES2020)
Used for very large integers beyond Number limit.

let big = 123456789012345678901234567890n;

Ends with n
Cannot mix with number

10n + 20n; // ‚úÖ
10n + 20;  // ‚ùå Error


6. Non-Primitive Examples
Object
let user = { name: "Suyog", age: 21 };

Array
let arr = [1, 2, 3];

Function
function greet() {}


7. Value vs Reference Example (Important ‚≠ê)
let a = 10;
let b = a;
b = 20;

console.log(a); // 10

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 5;

console.log(obj1.x); // 5

8. Common Interview Questions & Traps
Q1: typeof null? üëâ "object"

Q2: Is JavaScript statically typed? üëâ ‚ùå No, dynamically typed

Q3: Are strings mutable? üëâ ‚ùå No

Q4: Are arrays primitive? üëâ ‚ùå No, they are objects

9. One-Line Interview Answer ‚≠ê
JavaScript has primitive data types that store immutable values by value, and non-primitive types that store mutable data by reference.


1. What are Truthy & Falsy?
Falsy ‚Üí values that behave like false in a boolean context
Truthy ‚Üí everything else that behaves like true
JavaScript performs implicit boolean conversion when needed.

JavaScript has 8 falsy values including false, 0, "", null, undefined, NaN, -0, and 0n.
üëâ If a value is not in this list, it is truthy.


1. What is Type Coercion?

üëâ Type coercion is JavaScript‚Äôs automatic or manual conversion of one data type into another.

There are two types:
Implicit coercion (automatic)
Explicit coercion (manual)

2. Implicit Type Coercion (Automatic) ‚≠ê
JavaScript automatically converts types during operations.

2.1 String Coercion
+ operator
"5" + 2;     // "52"
5 + "2";     // "52"
üëâ If either operand is a string, result is a string.

2.2 Number Coercion
-, *, /
"5" - 2;   // 3
"5" * 2;   // 10
"10" / 2;  // 5
Strings are converted to numbers.


3. Explicit Type Coercion (Manual) ‚úÖ
You explicitly convert types using functions.

3.1 To String
String(10);     // "10"
(10).toString(); // "10"

3.2 To Number
Number("10");   // 10
parseInt("10"); // 10
parseFloat("10.5"); // 10.5


5. == vs === (Must Mention)
| Operator | Checks       | Coercion |
| -------- | ------------ | -------- |
| `==`     | Value        | ‚úÖ Yes    |
| `===`    | Value + Type | ‚ùå No     |

null == undefined; // true


2. null vs undefined (VERY COMMON QUESTION ‚≠ê)
üîπ undefined
Variable is declared but not assigned
Automatically assigned by JavaScript
let a; console.log(a); // undefined

üîπ null
Represents intentional absence of value
Explicitly assigned by developer
let b = null;

| Feature       | `null`                  | `undefined`        |
| ------------- | ----------------------- | ------------------ |
| Meaning       | Intentional empty value | Value not assigned |
| Assigned by   | Developer               | JavaScript         |
| Type          | `object` (JS bug)       | `undefined`        |
| Default value | ‚ùå No                    | ‚úÖ Yes              |

typeof null;      // "object" ‚ùå (bug)
typeof undefined; // "undefined"


2. Strict Mode ("use strict") ‚≠ê (VERY IMPORTANT)
What is Strict Mode?
üëâ Strict Mode is a restricted version of JavaScript that:
Catches common coding mistakes
Prevents unsafe actions
Makes code more secure & predictable

How to Enable Strict Mode
Entire Script

"use strict";
x = 10; // ‚ùå Error



1. What is Variable Shadowing?
Variable shadowing occurs when a variable declared in an inner scope has the same name as a variable in an outer scope. 
The inner variable ‚Äúshadows‚Äù (overrides) the outer one within its scope.

2. Basic Example

let x = 100; // Outer scope
function test() {
  let x = 50; // Inner scope shadows outer x
  console.log(x); // 50
}
test();
console.log(x); // 100 (outer x unaffected)



******* Hoisting Example (Declaration)
sayHello(); // ‚úÖ Works because function declarations are hoisted with body
function sayHello() {
  console.log("Hi!");
}


*********** Function Expression **********
greet(); // ‚ùå ReferenceError
const greet = function() {
  console.log("Hello!");
};

7. One-Line Interview Answers ‚≠ê
Function Declaration : A function declaration is fully hoisted, has a name, and can be called before it is defined.
Function Expression : A function expression is assigned to a variable, not hoisted fully, and cannot be called before the assignment.



1. What is an Arrow Function?
Arrow functions are shorter syntax for writing functions, introduced in ES6, and they do not have their own this, arguments, super, or new.target.

// Traditional function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b;
const square = x => x * x;
const sum = (a, b) => {
  const result = a + b;
  return result;
};



1. What is a Callback Function?
A callback function is a function passed as an argument to another function, which is then executed inside the outer function.
Callbacks are used for:
Asynchronous operations (AJAX, setTimeout, Promises)
Event handling
Functional programming (map, filter, forEach)

Example: Greeting User with Callback
// This is the callback function
function greetUser(name) {
  console.log("Hello, " + name + "!");
}

// This is the function that accepts a callback
function processUser(callback) {
  const userName = "Suyog";
  callback(userName); // Call the callback function
}

// Call the function and pass the callback
processUser(greetUser);






1. Rest Operator ...
The rest operator collects all remaining elements or arguments into an array.
Used in function parameters or destructuring
Must be last parameter in a function

1.1 Rest in Function Parameters
function sum(...numbers) {
  console.log(numbers);        // array of all arguments
  return numbers.reduce((a,b) => a + b, 0);
}

console.log(sum(1,2,3,4)); // 10

...numbers collects all arguments into an array
Works with any number of arguments


1.2 Rest in Array Destructuring
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first);  // 1
console.log(second); // 2
console.log(rest);   // [3,4,5]

1.3 Rest in Object Destructuring
const person = { name: "Suyog", age: 21, city: "Latur" };
const { name, ...others } = person;
console.log(name);   // "Suyog"
console.log(others); // { age: 21, city: "Latur" }


2. Spread Operator ...
The spread operator expands an array or object into individual elements.
Used in function calls, array literals, object literals

2.1 Spread in Arrays
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combined = [...arr1, ...arr2];
console.log(combined); // [1,2,3,4,5,6]

2.2 Spread in Function Calls
const nums = [1, 2, 3];
console.log(Math.max(...nums)); // 3

Expands array elements into individual arguments

2.3 Spread in Objects
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const combinedObj = { ...obj1, ...obj2 };
console.log(combinedObj); // { a:1, b:2, c:3, d:4 }


5. One-Line Interview Answers ‚≠ê
Rest Operator => The rest operator collects multiple elements or arguments into a single array.
Spread Operator => The spread operator expands an array or object into individual elements.



1. What is this in JavaScript?
The this keyword refers to the object that is currently executing the function, or the context in which a function is called.

2. this in Global Context
console.log(this);

In browser ‚Üí window object
In Node.js ‚Üí {} (module.exports)
In strict mode ‚Üí undefined



1. What is a Closure?
A closure is a function that remembers and has access to its lexical scope, even when the function is executed outside that scope.
Every function in JavaScript forms a closure naturally
Closures allow data privacy and function factories

2. Basic Example
function outer() {
  let count = 0; // local variable in outer function

  function inner() {
    count++;
    console.log(count);
  }

  return inner; // returning inner function
}

const counter = outer(); // outer() executed, returns inner
counter(); // 1
counter(); // 2
counter(); // 3


‚úÖ Explanation:
inner forms a closure over count
count persists between calls even though outer has finished execution



1. What is Asynchronous JavaScript?
Asynchronous JavaScript allows the program to perform long-running tasks without blocking the main thread, letting other code run while waiting for tasks 
like API calls, timers, or file operations to complete.

JS is single-threaded, so async operations use callbacks, promises, or async/await to handle delayed tasks.

2. Synchronous vs Asynchronous

2.1 Synchronous Example
console.log("Start");
console.log("Process");
console.log("End");

Output:
Start
Process
End

Each statement executes one after another


2.2 Asynchronous Example
console.log("Start");
setTimeout(() => {
  console.log("Inside Timeout");
}, 2000);
console.log("End");

Output:
Start
End
Inside Timeout

setTimeout is asynchronous ‚Üí non-blocking
JS continues executing the next lines


4. Common Ways to Handle Async in JS

4.1 Callbacks
function fetchData(callback) {
  setTimeout(() => {
    callback("Data received");
  }, 1000);
}

fetchData((data) => console.log(data));

Oldest method, can lead to callback hell


4.2 Promises
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Data received"), 1000);
});

fetchData
  .then((data) => console.log(data))
  .catch((err) => console.log(err));

Cleaner than callbacks
resolve ‚Üí success, reject ‚Üí error


4.3 Async / Await
function getData() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("Data received"), 1000);
  });
}

async function fetchData() {
  const data = await getData();
  console.log(data);
}

fetchData();


Makes async code look synchronous
Must use async keyword with await



1. Definition
Synchronous JavaScript
Code executes line by line, one statement after another.
Each operation blocks the next until it completes.

Asynchronous JavaScript
Code executes without blocking, allowing long-running tasks (like API calls or timers) to run in the background while other code continues.



1. What is the Event Loop?
The Event Loop is a mechanism in JavaScript that handles asynchronous operations, allowing non-blocking execution in a single-threaded environment.

JS is single-threaded ‚Üí only one call stack
Event Loop ensures callbacks, timers, and promises are executed at the right time

2. Components of Event Loop
1) Call Stack ‚Üí executes functions synchronously
2) Web APIs / Browser APIs ‚Üí handle async tasks (setTimeout, HTTP requests)
3) Callback Queue / Task Queue ‚Üí stores ready-to-run callbacks
4) Event Loop ‚Üí monitors the stack; moves queued callbacks to the stack when it‚Äôs empty

3. Example: Synchronous vs Asynchronous
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

console.log("End");


Output:
Start
End
Timeout


‚úÖ Explanation:
"Start" ‚Üí pushed to stack ‚Üí executed
setTimeout ‚Üí sent to Web API, then stack frees up
"End" ‚Üí executed
Event Loop moves callback from task queue to stack ‚Üí "Timeout" executed
Even with 0ms delay, setTimeout executes after current stack is empty



1. What is the Call Stack?
The Call Stack is a data structure (stack) that keeps track of function calls in JavaScript.
JS uses it to manage execution contexts in a synchronous manner
Last In, First Out (LIFO) ‚Üí the last function called is executed first

2. How Call Stack Works
JavaScript starts executing code ‚Üí global execution context is pushed to the stack
When a function is called ‚Üí new execution context is pushed on top of the stack
Function finishes ‚Üí execution context is popped from the stack
JS continues with the next context on the stack


1. What is the Callback Queue?
The Callback Queue (also called Task Queue / Message Queue) is a queue where asynchronous callbacks are stored after finishing in Web APIs, 
waiting to be executed by the Event Loop.

JavaScript is single-threaded, so async tasks cannot run immediately
Callbacks wait in the queue until the Call Stack is empty


2. How It Works with Event Loop
JS executes code ‚Üí synchronous functions go on Call Stack
Asynchronous tasks like setTimeout or DOM events are handled by Web APIs
Once ready, their callbacks go to the Callback Queue
Event Loop checks if Call Stack is empty, then moves callbacks from queue to stack



1. What is Callback Hell?
Callback Hell occurs when callbacks are nested inside other callbacks multiple levels deep, making the code hard to read, maintain, and debug.
Happens mostly in asynchronous JavaScript
Often referred to as ‚ÄúPyramid of Doom‚Äù due to indentation levels

2. Example of Callback Hell
doSomething(function(result) {
    doSomethingElse(result, function(newResult) {
        doThirdThing(newResult, function(finalResult) {
            console.log("Final Result: " + finalResult);
        });
    });
});

Problems:
Deeply nested code ‚Üí hard to read
Hard to handle errors
Difficult to maintain or extend


3. Real-Life Analogy
Imagine giving instructions like:
‚ÄúDo A, then do B, then do C‚Ä¶‚Äù
If each step depends on the previous one, instructions get nested and confusing


4. How to Avoid Callback Hell

4.2 Using Promises
doSomething()
  .then(result => doSomethingElse(result))
  .then(newResult => doThirdThing(newResult))
  .then(finalResult => console.log("Final Result: " + finalResult))
  .catch(err => console.log(err));


Promises flatten the structure
Provide better error handling with .catch()


4.3 Using Async / Await (ES7+)
async function processTasks() {
    try {
        const result = await doSomething();
        const newResult = await doSomethingElse(result);
        const finalResult = await doThirdThing(newResult);
        console.log("Final Result: " + finalResult);
    } catch (err) {
        console.log(err);
    }
}

processTasks();

‚úÖ Makes asynchronous code look synchronous, very readable


5. Common Interview Points
Explain what Callback Hell is ‚Üí nested asynchronous callbacks
Show why it‚Äôs a problem ‚Üí readability, maintainability
Explain solutions ‚Üí named functions, Promises, async/await
Mention error handling becomes difficult with callbacks

6. One-Line Interview Answer ‚≠ê
Callback Hell is when asynchronous callbacks are nested multiple levels, making code unreadable and hard to maintain; it can be solved using Promises or async/await.



1. What is a Promise?
A Promise is an object that represents the eventual completion or failure of an asynchronous operation.

A Promise can be in one of three states:
Pending ‚Äì initial state, not fulfilled or rejected
Fulfilled ‚Äì operation completed successfully
Rejected ‚Äì operation failed

Introduced in ES6 to avoid callback hell


2. Basic Promise Example
const myPromise = new Promise((resolve, reject) => {
  const success = true;

  if (success) {
    resolve("Operation Successful!");
  } else {
    reject("Operation Failed!");
  }
});

myPromise
  .then((result) => console.log(result))  // Operation Successful!
  .catch((error) => console.log(error));


‚úÖ Explanation:
resolve() ‚Üí marks promise as fulfilled
reject() ‚Üí marks promise as rejected
.then() handles success, .catch() handles errors


3. Promises in Asynchronous Code
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => {
    const data = "Data received";
    resolve(data);
  }, 1000);
});

fetchData.then((result) => console.log(result));

Output after 1 second:
Data received


4. Promise Chaining
new Promise((resolve, reject) => {
  resolve(5);
})
  .then((num) => num * 2)       // 10
  .then((num) => num + 3)       // 13
  .then((num) => console.log(num)); // 13

‚úÖ Each .then() receives the return value from the previous .then()


5. Error Handling in Promises
new Promise((resolve, reject) => {
  reject("Something went wrong");
})
  .then((result) => console.log(result))
  .catch((error) => console.log("Error: " + error));

.catch() handles any error in the chain


1. Promise States
A Promise can be in three states:
| State                    | Description                                          |
| ------------------------ | ---------------------------------------------------- |
| **Pending**              | Initial state; neither fulfilled nor rejected        |
| **Fulfilled / Resolved** | Operation completed successfully; triggers `.then()` |
| **Rejected**             | Operation failed; triggers `.catch()`                |

‚úÖ Explanation:
.then() ‚Üí executed when Promise is fulfilled
.catch() ‚Üí executed when Promise is rejected

3. .finally()
.finally() is executed regardless of the promise outcome
Useful for cleanup tasks

const myPromise = new Promise((resolve, reject) => {
  resolve("Done");
});

myPromise
  .then((result) => console.log("Then:", result))
  .catch((err) => console.log("Catch:", err))
  .finally(() => console.log("Finally: Cleanup"));

Output:
Then: Done
Finally: Cleanup


Even if rejected, .finally() runs:

Promise.reject("Failed")
  .catch(err => console.log(err))
  .finally(() => console.log("Cleanup")); 

// Output:
// Failed
// Cleanup



1. What is Async / Await?
Async / Await is syntactic sugar over Promises that makes asynchronous code look and behave like synchronous code.

üëâ Introduced in ES2017 (ES8)

One-line interview answer ‚≠ê
Async/Await is a modern way to handle asynchronous operations in JavaScript, built on top of Promises, that improves readability and error handling.

2. async Keyword
async is used before a function
An async function always returns a Promise
If you return a value ‚Üí it‚Äôs wrapped in Promise.resolve()

async function greet() {
  return "Hello";
}

greet().then(console.log); // Hello


Equivalent to:

function greet() {
  return Promise.resolve("Hello");
}


3. await Keyword
await pauses execution of the async function
Waits for the Promise to resolve or reject

Can be used only inside async functions

async function fetchData() {
  const result = await Promise.resolve("Data loaded");
  console.log(result);
}

fetchData();


‚ö†Ô∏è Important:
await does not block the main thread
It only pauses the current async function

4. Basic Async/Await Example
function getData() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("Data received"), 1000);
  });
}

async function showData() {
  const data = await getData();
  console.log(data);
}

showData();

Output after 1 second:
Data received


5. Error Handling with Try‚ÄìCatch

Async/Await uses try‚Äìcatch instead of .catch()

async function fetchUser() {
  try {
    const user = await Promise.reject("User not found");
    console.log(user);
  } catch (error) {
    console.log("Error:", error);
  }
}

fetchUser();

‚úî Cleaner and more readable than promise chaining


Q: Does async/await block JavaScript?
üëâ No, it pauses only the async function, not the main thread.


6. Async/Await vs Promises
| Promises                    | Async / Await       |
| --------------------------- | ------------------- |
| `.then().catch()`           | `try { } catch { }` |
| Harder to read when chained | More readable       |
| Callback-like style         | Synchronous-looking |
| Explicit chaining           | Linear flow         |


10. One-Minute Interview Answer ‚≠ê
Promises and async/await both handle asynchronous operations. Promises use chaining with .then() and .catch(), while 
async/await is syntactic sugar on top of Promises that allows writing asynchronous code in a synchronous style with better readability and easier error handling.



1Ô∏è‚É£ Memory Heap
What is Memory Heap?
Memory Heap is the region of memory where objects, arrays, and functions are stored dynamically during program execution.

Key Points
Stores non-primitive (reference) types
Memory allocation is dynamic
Managed by Garbage Collector
No fixed order

Example
let user = {
  name: "Suyog",
  age: 22
};

Object {name, age} ‚Üí stored in heap
Variable user ‚Üí stored in stack as a reference


2Ô∏è‚É£ Stack (Call Stack)
What is Stack?
Stack is a memory structure that stores primitive values and execution contexts using LIFO (Last In, First Out) order.

Key Points
Stores primitive data types
Stores function execution contexts
Fixed size (limited)
Fast access


3Ô∏è‚É£ Stack Example
function first() {
  second();
}

function second() {
  console.log("Hello");
}

first();

Stack Flow
| second() |
| first()  |
| global   |


4Ô∏è‚É£ Stack vs Heap (Most Asked Table)
| Feature           | Stack                         | Heap                       |
| ----------------- | ----------------------------- | -------------------------- |
| Type              | Structured                    | Unstructured               |
| Stores            | Primitives, execution context | Objects, arrays, functions |
| Access            | Very fast                     | Slower than stack          |
| Size              | Limited                       | Large                      |
| Memory allocation | Static                        | Dynamic                    |
| Managed by        | JS Engine                     | Garbage Collector          |
| Error             | Stack Overflow                | Memory Leak                |


5Ô∏è‚É£ Stack & Heap Together (Very Important)
let a = 10;
let b = a;
let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 5;
console.log(a);       // 10
console.log(obj1.x);  // 5

Explanation
a, b ‚Üí primitives ‚Üí copied by value (stack)
obj1, obj2 ‚Üí reference ‚Üí both point to same heap memory


8Ô∏è‚É£ Common Interview Mistakes ‚ö†Ô∏è

‚ùå ‚ÄúStack stores objects‚Äù
‚úî Stack stores references to heap objects

‚ùå ‚ÄúHeap is faster than stack‚Äù
‚úî Stack is faster


9Ô∏è‚É£ One-Minute Interview Answer ‚≠ê
Stack is a LIFO memory structure that stores primitive values and execution contexts, while Heap is a large memory area used for dynamic allocation
of objects and reference types, managed by garbage collection.



9Ô∏è‚É£ One-Minute Interview Answer ‚≠ê
A shallow copy copies only top-level properties, sharing references for nested objects, while a deep copy duplicates all nested objects, 
creating completely independent memory references.


One-line interview answer ‚≠ê
Template literals allow embedding expressions inside strings using backticks and ${} syntax, making strings more readable and powerful.

2Ô∏è‚É£ Syntax
`string text ${expression}`

Uses backticks ( ` ), not quotes
Expressions are placed inside ${}


1Ô∏è‚É£ What is Error Handling?
Error handling is the process of detecting, handling, and responding to runtime errors so that the application doesn‚Äôt crash unexpectedly.

One-line interview answer ‚≠ê
Error handling in JavaScript allows us to catch runtime errors and handle them gracefully using try, catch, finally, and custom errors.

3Ô∏è‚É£ try‚Äìcatch‚Äìfinally
Basic Syntax
try {
  // code that may throw error
} catch (error) {
  // error handling
} finally {
  // always runs
}


1Ô∏è‚É£ What is throw?
The throw statement is used to manually generate (throw) an error in JavaScript.
It immediately stops execution of the current code block and transfers control to the nearest catch.

4Ô∏è‚É£ Throwing Custom Errors (throw)
function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero is not allowed");
  }
  return a / b;
}

try {
  divide(10, 0);
} catch (err) {
  console.log(err.message);
}

‚úî Improves debugging
‚úî Helps validation



1Ô∏è‚É£ What is DOM?
DOM (Document Object Model) is a programming interface that represents an HTML document as a tree of objects, allowing JavaScript to read, modify, 
and manipulate web pages dynamically.

One-line interview answer ‚≠ê
The DOM is a tree-like representation of an HTML document that JavaScript uses to access and manipulate page elements.

2Ô∏è‚É£ DOM Tree Structure

Example HTML:

<html>
  <body>
    <h1>Hello</h1>
    <p>Welcome</p>
  </body>
</html>


DOM Tree:

Document
 ‚îî‚îÄ‚îÄ html
     ‚îî‚îÄ‚îÄ body
         ‚îú‚îÄ‚îÄ h1
         ‚îÇ   ‚îî‚îÄ‚îÄ "Hello"
         ‚îî‚îÄ‚îÄ p
             ‚îî‚îÄ‚îÄ "Welcome"

‚úî Every element, attribute, and text is a node


3Ô∏è‚É£ Types of DOM Nodes
| Node Type      | Description                    |
| -------------- | ------------------------------ |
| Element Node   | HTML elements (`<div>`, `<p>`) |
| Text Node      | Text inside elements           |
| Attribute Node | Attributes like `id`, `class`  |
| Document Node  | Entire document                |


4Ô∏è‚É£ Accessing DOM Elements
By ID
document.getElementById("title");

By Class
document.getElementsByClassName("box");

Returns HTMLCollection
Live collection (updates automatically)
Cannot use array methods directly


By Tag
document.getElementsByTagName("p");

Modern Selectors (Most Used ‚≠ê)

document.querySelector(".box");
Returns first matching element


document.querySelectorAll(".box");
Returns NodeList
Static (does not auto-update)
Supports forEach()


5Ô∏è‚É£ Accessing Multiple Elements
HTMLCollection
const boxes = document.getElementsByClassName("box");
boxes[0].style.color = "red";

NodeList
const boxes = document.querySelectorAll(".box");
boxes.forEach(box => box.style.color = "blue");


9Ô∏è‚É£ One-Minute Interview Answer ‚≠ê
DOM selection methods allow selecting HTML elements for manipulation. Traditional methods like getElementById() and getElementsByClassName() return HTMLCollections, 
while modern methods like querySelector() and querySelectorAll() use CSS selectors and return NodeLists.


5Ô∏è‚É£ Modifying DOM Elements

Change Content
element.textContent = "Hello";
element.innerHTML = "<b>Hello</b>";

‚ö†Ô∏è innerHTML can cause XSS vulnerabilities


Change Styles
element.style.color = "red";


Change Attributes
element.setAttribute("id", "newId");
element.getAttribute("id");


6Ô∏è‚É£ Creating & Removing Elements

Create
const div = document.createElement("div");
div.textContent = "New Element";
document.body.appendChild(div);

Remove
div.remove();


7Ô∏è‚É£ DOM Events
button.addEventListener("click", () => {
  alert("Button clicked");
});

‚úî Preferred over onclick



1Ô∏è‚É£ What is Event Handling?
Event handling is the process of detecting user actions (like click, input, mouseover) and executing code in response.

One-line interview answer ‚≠ê
Event handling in JavaScript allows us to respond to user interactions like clicks, typing, or scrolling by attaching event listeners to DOM elements.


2Ô∏è‚É£ Ways to Handle Events
3. Using addEventListener() (Recommended ‚≠ê)
const btn = document.querySelector("#btn");
btn.addEventListener("click", function() {
  alert("Clicked!");
});

‚úÖ Allows multiple handlers
‚úÖ Supports event capturing/bubbling


3Ô∏è‚É£ Event Object
btn.addEventListener("click", function(event) {
  console.log(event.type);   // "click"
  console.log(event.target); // element clicked
});

event.target ‚Üí element that triggered event
event.currentTarget ‚Üí element listener is attached to
event.preventDefault() ‚Üí prevent default action
event.stopPropagation() ‚Üí stop bubbling/capturing


4Ô∏è‚É£ Event Types
1. Mouse Events
click, dblclick, mouseenter, mouseleave, mousemove, contextmenu

2. Keyboard Events
keydown, keyup, keypress

3. Form Events
submit, change, input, focus, blur

4. Window / Document Events
load, resize, scroll, DOMContentLoaded, beforeunload


6Ô∏è‚É£ Removing Event Listeners
function clickHandler() {
  console.log("Clicked!");
}

btn.addEventListener("click", clickHandler);
btn.removeEventListener("click", clickHandler);

‚ö†Ô∏è Must provide the same function reference



2Ô∏è‚É£ Event Capturing (Trickling)
The event starts at the document/root and goes down to the target element.
Rarely used; less common than bubbling.
Controlled by the third parameter of addEventListener.

const parent = document.getElementById("parent");
const child = document.getElementById("child");

parent.addEventListener("click", () => {
  console.log("Parent Capturing");
}, true); // true = capturing

child.addEventListener("click", () => {
  console.log("Child Capturing");
}, true);

child.click();

Output:
Parent Capturing
Child Capturing


3Ô∏è‚É£ Event Bubbling
Most events bubble by default.
Event starts at target element and travels up to root.

const parent = document.getElementById("parent");
const child = document.getElementById("child");

parent.addEventListener("click", () => {
  console.log("Parent Bubbling");
}, false); // false = bubbling (default)

child.addEventListener("click", () => {
  console.log("Child Bubbling");
}, false);

child.click();

Output:
Child Bubbling
Parent Bubbling


5Ô∏è‚É£ stopPropagation()
event.stopPropagation() ‚Üí stops further propagation (bubble/capture)


9Ô∏è‚É£ One-Minute Interview Answer ‚≠ê
When an event occurs in the DOM, it propagates in three phases: capturing (top ‚Üí target), target, and bubbling (target ‚Üí top). 
Capturing is controlled by addEventListener(..., true) and bubbling is the default. stopPropagation() can stop further propagation.


1Ô∏è‚É£ What is preventDefault()?
event.preventDefault() is a method that prevents the browser‚Äôs default action for a particular event from occurring.

One-line interview answer ‚≠ê
preventDefault() stops the default behavior of an event while still allowing your custom JavaScript logic to run.



1Ô∏è‚É£ What is Garbage Collection?
Garbage Collection in JavaScript is an automatic process where the engine frees memory occupied by objects that are no longer reachable or needed, preventing memory leaks.

One-line interview answer ‚≠ê
Garbage collection automatically cleans up memory by removing objects that are no longer referenced in the program.
