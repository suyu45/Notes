__builtin_popcount(x) gives the number of 1-bits in x.
stoi() 
stoll()
to_string(val3)
long long val1 = stoll(first);
string third = to_string(val3);
string second = num.substr(index, length);
s.erase(s.size() - 5);  // removes last 5 characters

ğŸ“Š Bonus: Get Max + Index
auto it = max_element(v.begin(), v.end());
int mx = *it;
int index = it - v.begin();

int mx = *max_element(v.begin(), v.end());

sort(jobs.rbegin(), jobs.rend());   // descending

int high = accumulate(jobs.begin(), jobs.end(), 0);

int gcdVal = __gcd(nums1, nums2);


vector<vector<int>> score;
score.assign(m, vector<int>(m, 0));



for (string num : nums)   integers.insert(stoi(num, 0, 2));

âœ” stoi(num, 0, 2) converts a binary string to an integer
Example: "11" â†’ 3


string ans = bitset<16>(num).to_string();
âœ” Converts num into a 16-bit binary string

Example: num = 2 => "0000000000000010"

return ans.substr(16 - n);
We only need the last n bits

Example: n = 2
"0000000000000010".substr(14) â†’ "10"






1) Binary search

Binary Search is a search algorithm used on sorted arrays (or ranges) to find the position of a target value.
It repeatedly divides the search interval in half. (divide ad conquer algorithm)

Precondition: Array must be sorted.

| Case    | Time     | Space |
| ------- | -------- | ----- |
| Best    | O(1)     | O(1)  |
| Average | O(log n) | O(1)  |	
| Worst   | O(log n) | O(1)  |


2) stack

A stack is a linear data structure that follows the LIFO (Last In First Out) principle â€” the last element inserted is the first to be removed.
Examples:
Stack of plates,Undo feature in editors,Browser back button,Recursion call stack

| Operation     | Description / Use                                      | Time Complexity |
|---------------|--------------------------------------------------------|-----------------|
| push(x)       | Add element x to the top of the stack                  | O(1)            |
| pop()         | Remove the top element                                 | O(1)            |
| peek() / top()| Get the top element without removing it                | O(1)            |
| isEmpty()     | Check if the stack is empty                            | O(1)            |
| size()        | Return the number of elements in the stack             | O(1)            |

Monotonic Stack -> A monotonic stack is a stack that maintains elements in increasing or decreasing order.

Stack in Recursion -> During recursion, function calls are stored in the call stack. Each recursive call is pushed onto the stack, 
and once the function completes, it's popped off. This allows the program to return to the correct previous state.



******************  Sorting  ************************

| Algorithm       | Idea (Concept)                                      | Best Case  | Avg Case   | Worst Case | Space    | Stable  | In-place  | Best Use Case                                 |
| --------------- | --------------------------------------------------- | ---------- | ---------- | ---------- | -------- | ------  | --------  | --------------------------------------------- |
| **Bubble Sort** | Repeatedly swap adjacent elements if out of order   | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     | âœ… Yes  | âœ… Yes    | Small / nearly sorted arrays, teaching basics |
| **Selection**   | Select min element, place at beginning              | O(nÂ²)      | O(nÂ²)      | O(nÂ²)      | O(1)     | âŒ No   | âœ… Yes    | Few swaps needed, simple logic                |
| **Insertion**   | Insert element into correct position in sorted part | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     | âœ… Yes  | âœ… Yes    | Nearly sorted or small arrays                 |
| **Quick Sort**  | Partition around pivot, sort subarrays              | O(n log n) | O(n log n) | O(nÂ²)      | O(log n) | âŒ No   | âœ… Yes    | Large datasets, fastest in practice           |
| **Merge Sort**  | Divide array, sort halves, merge                    | O(n log n) | O(n log n) | O(n log n) | O(n)     | âœ… Yes  | âŒ No     | Linked lists, stability required              |
| **Heap Sort**   | Build max heap, extract max, heapify                | O(n log n) | O(n log n) | O(n log n) | O(1)     | âŒ No   | âœ… Yes    | Guaranteed O(n log n) in-place sort           |


ğŸ” Key Definitions (Interview Must-Know)
ğŸ”¹ Adaptive : A sorting algorithm is adaptive if it takes less time for partially sorted input.
âœ” Example: Insertion Sort performs in O(n) for nearly sorted arrays.

ğŸ”¹ Stable : A sorting algorithm is stable if it preserves the relative order of equal elements.


| Sorting Algorithm  | Adaptive  | Stable   | In-Place  | Time Complexity (Avg) |
| ------------------ | --------  | -------  | --------  | --------------------- |
| **Bubble Sort**    | âœ… Yes    | âœ… Yes   | âœ… Yes    | O(nÂ²)                 |
| **Selection Sort** | âŒ No     | âŒ No    | âœ… Yes    | O(nÂ²)                 |
| **Insertion Sort** | âœ… Yes    | âœ… Yes   | âœ… Yes    | O(nÂ²)                 |
| **Merge Sort**     | âŒ No     | âœ… Yes   | âŒ No     | O(n log n)            |
| **Quick Sort**     | âŒ No     | âŒ No    | âœ… Yes    | O(n log n)            |
| **Heap Sort**      | âŒ No     | âŒ No    | âœ… Yes    | O(n log n)            |



Quick Memory Hooks
Stable Sorts: BIM â†’ Bubble, Insertion, Merge
In-place: All except Merge
Guaranteed O(n log n): Merge, Heap
Best for large data: Quick (fast), Merge (stable)
Best for nearly sorted: Insertion

Idea keywords:
Bubble â†’ Swap Adjacent (â€œbubbleâ€ largest to the end).
Selection â†’ Select Min  (Find minimum element in unsorted part, place it at beginning.)
Insertion â†’ Insert in Sorted ( Insert each element into its correct position in the sorted part.)
Quick â†’ Pivot Partition (Choose pivot, partition array into < pivot and > pivot, recursively sort.)
Merge â†’ Divide & Merge ( Divide array into halves, sort each half, merge sorted halves.)
Heap â†’ Heapify & Extract (Build max heap, repeatedly extract max element, heapify remaining.)


In C++, `std::sort` (from `<algorithm>`) uses a **hybrid sorting algorithm called IntroSort**.
It works like this:
* **Starts with Quicksort** for fast average performance.
* If recursion depth becomes too large (to avoid worst-case O(nÂ²)), it **switches to Heapsort** to ensure O(n log n) worst-case time.
* For very small subarrays, it uses **Insertion sort** for better efficiency.
* Best case: O(n log n)
* Average case: O(n log n)
* Worst case: O(n log n)

sort(nums.begin(), nums.end(), greater<int>());


ğŸ“Œ What is IntroSort?
IntroSort starts with Quick Sort, but if recursion goes too deep (indicating bad pivot choices), it switches to Heap Sort.
For small subarrays, it uses Insertion Sort.
ğŸ‘‰ This avoids Quick Sortâ€™s O(nÂ²) worst case.


************************************* Sliding window and 2 pointer ********************************************
1.Fixed-size window
  Window size k is constant.
  Example: Max sum of subarray of size k.

2.Variable-size window ( longest subarray / substring where <condition> )
  Window expands/contracts until a condition is met.
  Example: Longest subarray where sum <= k.

3. No. of subarray where <condition> 
  using pattern 2 ==>  
  (No. of subarray where  sum = k)  = (No. of subarray where  sum <= k) - (No. of subarray where  sum <= (k-1))
  ans = x-y

4.Shortest / Minimum window <condition>



