express â€“ Express.js, often referred to simply as Express, is a minimal and flexible Node.js web application framework designed for building web applications and APIs. 
          It is a popular and widely used framework within the Node.js ecosystem, often considered the de facto standard for server-side development with Node.js. 
          In essence, Express.js simplifies and enhances the process of building server-side applications and APIs with Node.js by providing a structured and efficient way 
          to handle HTTP requests, manage routing, and implement various functionalities through its middleware system.

dotenv/config â€“ automatically loads .env file (containing secrets like MONGO_URI, JWT_SECRET, PORT).

cookie-parser â€“ allows server to read cookies (used for JWT tokens or session IDs).

cors â€“ enables cross-origin requests (important since frontend runs on a different port).

path â€“ helps resolve file paths safely across platforms.

1)authRoutes, 
2)userRoutes, 
3)chatRoutes 
â€“ modular route handlers for authentication, user management, and chat operations.

************************* CORS Middleware ******************
Allows your React frontend (Vite on port 5173) to communicate with backend.
credentials: true lets cookies/JWT tokens be shared securely.


express.json() parses incoming JSON requests.

cookieParser() extracts cookies from client requests.


1ï¸âƒ£ What is the role of cors() here?
Answer: It enables requests from a different origin (the frontend). Since the React app runs on a different port (5173), CORS allows the browser to make secure API calls 
          and include cookies/tokens.

2ï¸âƒ£ Why is credentials: true important?
Answer: It lets browsers send authentication cookies (or JWT tokens) with cross-origin requests. Without it, the server canâ€™t identify logged-in users.

5ï¸âƒ£ What is the use of cookieParser()?
Answer: It parses cookies attached to client requests so they can be accessed via req.cookies. Useful for authentication tokens stored in cookies.

6ï¸âƒ£ How are frontend routes handled in production?
Answer: All non-API routes (*) serve the index.html file from the React build folder, letting React Router handle client-side navigation.

7ï¸âƒ£ What is path.resolve() doing here?
Answer: It returns the absolute path of the current directory (__dirname), which is necessary for serving static files correctly.



********************************************************** 1)authRoutes ******************************************
/signup â†’ Registers new users (usually stores hashed passwords, creates tokens).
/login â†’ Verifies credentials, issues authentication token or cookie.
/logout â†’ Clears session/cookie or invalidates token.
These routes are public (no authentication required).

Protected Routes
router.post("/onboarding", protectRoute, onboard);


protectRoute middleware runs first:
Checks if user is authenticated (usually by decoding JWT).
If valid, attaches user info to req.user.

Then calls onboard controller, which completes user setup (e.g., saving preferences, profile info).


Session Check Route
router.get("/me", protectRoute, (req, res) => {
  res.status(200).json({ success: true, user: req.user });
});

Returns the currently logged-in userâ€™s data.

Useful for restoring sessions (e.g., after page refresh, to auto-login).


| Route                  | Auth Required | HTTP | Description                       |
| ---------------------- | ------------- | ---- | --------------------------------- |
| `/api/auth/signup`     | âŒ             | POST | Register new user                 |
| `/api/auth/login`      | âŒ             | POST | Log user in                       |
| `/api/auth/logout`     | âŒ             | POST | Log user out (clear cookie/token) |
| `/api/auth/onboarding` | âœ…             | POST | Setup user profile after auth     |
| `/api/auth/me`         | âœ…             | GET  | Check if token/session is valid   |



1ï¸âƒ£ What is the role of protectRoute middleware?
Answer:
It checks whether a user is authenticated before allowing access to protected routes. Typically, it:
Reads JWT token from cookies or headers.
Verifies the token with JWT_SECRET.
Attaches decoded user info to req.user.
If verification fails â†’ returns 401 Unauthorized.

5ï¸âƒ£ What does the logout route do internally?
Answer:
Usually clears the cookie storing JWT (using res.clearCookie("token")) or invalidates the token server-side (if stored in DB or cache).
This effectively ends the userâ€™s session.

6ï¸âƒ£ Why use POST for logout instead of GET?
Answer:
Logout changes the serverâ€™s state (removing a session/cookie).
POST is safer than GET (which should be idempotent and not alter state).




âœ… Interview Answer: Explain Your Project in Brief

â€œMy project is a real-time video calling and language-learning social platform called Streamify Video Calls.
It allows users to connect with people worldwide, make friends, and communicate through chat and video calls.
On the backend, I built the system using Node.js, Express, MongoDB, and JWT authentication. The project is structured using the MVC pattern.

Key features I implemented:
1. User Authentication & Onboarding
Secure login and signup using JWT, password hashing with bcrypt,
Users complete onboarding with profile details, languages, and preferences.

2. Stream Video-Call Integration
I integrated Stream API (StreamChat) to generate tokens and upsert users into the Stream platform.
This allows us to enable real-time chat and video calling without managing WebRTC manually.

3. Friend System (Like Social Media)
I built a complete friend-management system:
- Send friend requests
- Accept requests
- Incoming & outgoing requests
- Friend list
- Recommended users (excluding current user & existing friends)

This uses two Mongoose models:
User
FriendRequest

4. Protected Routes & Middleware
All user-related APIs are protected using a custom auth middleware.
Middleware validates the JWT and injects the authenticated user into the request.

5. Clean and Scalable API Architecture
I separated everything into:
Routes
Controllers
Models
Stream utility (stream.js)

This makes the code modular and production-ready.

6. Database Management with MongoDB
Used Mongoose schemas with pre-save hooks (password hashing)
Used $addToSet, $nin, $ne queries for efficient friend recommendation and relationship management

ğŸ¯ Short and impressive version (if interviewer wants very brief)
â€œMy project is a real-time video calling and social interaction platform.
Users can sign up, create profiles, send and accept friend requests, and join video calls using Stream API.
On the backend, I implemented secure authentication, friend management, and Stream token generation using Node.js, Express, MongoDB, and structured everything using the MVC pattern.â€





ğŸ”· 1. Client â†’ Server â†’ Stream API Architecture
Frontend (React/Next.js)
      â†“ HTTP requests (Axios/Fetch)
Backend (Node.js + Express)
      â†“
Controllers â†’ Services â†’ Database (MongoDB)
      â†“
Stream API (for chat + video calls)


â­ Database Schema Design : 1) User, 2) FriendRequest
ğŸ—„ï¸ Database Schema Diagram (High-Level)
Users
 â”œâ”€â”€ _id
 â”œâ”€â”€ fullName
 â”œâ”€â”€ email
 â”œâ”€â”€ password (hashed)
 â”œâ”€â”€ bio
 â”œâ”€â”€ profilePic
 â”œâ”€â”€ nativeLanguage
 â”œâ”€â”€ learningLanguage
 â”œâ”€â”€ location
 â”œâ”€â”€ isOnboarded
 â””â”€â”€ friends â†’ [User._id]

FriendRequests
 â”œâ”€â”€ sender â†’ User._id
 â”œâ”€â”€ recipient â†’ User._id
 â””â”€â”€ status ("pending" | "accepted")


â­ 2. Challenge: Preventing Duplicate Friend Requests
Problem : Users were able to send the same friend request multiple times or even send a request to themselves.

What I did
Added validation to block:
- Self requests
- Requests to existing friends
- Duplicate pending requests

Used MongoDB query:

$or: [
  { sender: myId, recipient: recipientId },
  { sender: recipientId, recipient: myId }
]

Outcome : The friend request system became consistent, clean, and impossible to exploit.




â­ 6. Challenge: Designing Friend Recommendation Logic
Problem => 
Recommended users should exclude:
- The logged-in user
- Already added friends
- Not-yet-onboarded users

What I did

Wrote MongoDB query using:
$ne, $nin, $and

Outcome : The recommendation feature became accurate and efficient.



âœ… Where does your project store chats between friends?
âœ… Your project does NOT store chats in your MongoDB database.
There is no Message model and no custom chat persistence in your backend.
But your project does store chats â€” using Stream (GetStream) Chat API.

ğŸ”¥ Where are chats stored?
ğŸ‘‰ Chats are stored on Streamâ€™s own servers (GetStream Cloud Infrastructure).

StreamChat is a managed real-time messaging platform, so your backend does NOT need to:
âŒ create a message schema
âŒ save messages to MongoDB
âŒ manage chat channels manually

Instead, Stream handles:
âœ” chat history
âœ” channels
âœ” real-time messaging
âœ” user typing indicators
âœ” unread counts
âœ” message persistence
âœ” message search


ğŸ“Œ So the final answer for interview:
â€œWhere are chats stored in your project?â€
All chat messages and chat channels in my Streamify application are stored using the Stream Chat API (GetStream).
My backend only generates Stream user accounts and secure auth tokens.
Stream automatically manages message storage, channels, message history, real-time updates, and scalability on their cloud infrastructure.
So the chat data is not stored in MongoDB â€” it is stored and managed entirely by Stream.â€





ğŸ”„ COMPLETE WORKFLOW OF FRIEND REQUEST SYSTEM

### ğŸ”¹ Step 1: User Sends Friend Request
API: POST /api/users/friend-request/:id

Validations checked:
âœ” Cannot send request to yourself
âœ” Recipient must exist
âœ” Already friends? â†’ reject
âœ” Already a pending request both directions? â†’ reject

If valid â†’ create:
FriendRequest.create({
  sender: myId,
  recipient: recipientId,
  status: "pending"
});


### ğŸ”¹ Step 2: User Receives Pending Requests
API: GET /api/users/friend-requests

Fetches:
incomingReqs = FriendRequest.find({
  recipient: req.user.id,
  status: "pending"
})

âœ” Populates sender profile
âœ” Used to show â€œAccept / Reject Requestâ€ UI


### ğŸ”¹ Step 3: User Accepts Friend Request
API: PUT /api/users/friend-request/:id/accept

Flow:
1ï¸âƒ£ Validate request exists
2ï¸âƒ£ Check current user = recipient
3ï¸âƒ£ Update request status â†’ "accepted"
4ï¸âƒ£ Add EACH USER to the other's friend list:

await User.findByIdAndUpdate(senderId, {
  $addToSet: { friends: recipientId }
});

await User.findByIdAndUpdate(recipientId, {
  $addToSet: { friends: senderId }
});


### ğŸ”¹ Step 4: Store Final Friends List
Once accepted, both users get:
"friends": [ "friendId1", "friendId2", ... ]

This is used in:
âœ” Chat system (show friends available for calls)
âœ” Recommended users (exclude existing friends)
âœ” UI sidebar friend list



âœ… Simple Explanation of How I Implement Video Calls

â€œI added video calling to my project using Streamâ€™s Video API.
Stream works on top of WebRTC â€” which is the technology that actually sends video and audio between two people.
My backend does not handle video directly.
It only creates a Stream token for each user so they can securely join a call.
When a user wants to start or join a call, the frontend uses Streamâ€™s SDK along with this token.
Stream then takes care of the complicated parts like:
- finding and connecting both users
- sharing network details between them
- managing the call room
After Stream finishes this setup, WebRTC ( web Real Time communication) automatically creates a direct peer-to-peer video connection between both users.
This allows smooth and high-quality video and audio communication.â€




âœ… Improvements & New Features I Would Add

â­ 5. Add User Blocking / Reporting
ğŸ”¥ Why? => Prevents harassment and spam.

ğŸ›  How:
Add blockedUsers: [] array in User model.
Modify friend request endpoint to check: if (recipient.blockedUsers.includes(myId)) reject
Add a /block/:id route.


â­ 6. Add Group Calls
ğŸ”¥ Why? => Expands platform usage â†’ group study, team meetings, group chat.

ğŸ›  How:
Use Streamâ€™s "Call Type: default".
Create group rooms with dynamic participant list.
Modify frontend UI to support multiple tiles (grid layout).


â­ 7. Improve Friend Recommendation System
Reason: Right now your recommendation is simple:
â¡ï¸ â€œShow users who are not my friends and not meâ€.

How to Improve:
Add machine learning-based recommendations
Suggest users based on:
Same native/learning language
Same location
Common friends
Interests in bio
