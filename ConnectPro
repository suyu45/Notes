express â€“ Express.js, often referred to simply as Express, is a minimal and flexible Node.js web application framework designed for building web applications and APIs. 
          It is a popular and widely used framework within the Node.js ecosystem, often considered the de facto standard for server-side development with Node.js. 
          In essence, Express.js simplifies and enhances the process of building server-side applications and APIs with Node.js by providing a structured and efficient way 
          to handle HTTP requests, manage routing, and implement various functionalities through its middleware system.

dotenv/config â€“ automatically loads .env file (containing secrets like MONGO_URI, JWT_SECRET, PORT).

cookie-parser â€“ allows server to read cookies (used for JWT tokens or session IDs).

cors â€“ enables cross-origin requests (important since frontend runs on a different port).

path â€“ helps resolve file paths safely across platforms.

1)authRoutes, 
2)userRoutes, 
3)chatRoutes 
â€“ modular route handlers for authentication, user management, and chat operations.

************************* CORS Middleware ******************
Allows your React frontend (Vite on port 5173) to communicate with backend.
credentials: true lets cookies/JWT tokens be shared securely.


express.json() parses incoming JSON requests.

cookieParser() extracts cookies from client requests.


1ï¸âƒ£ What is the role of cors() here?
Answer: It enables requests from a different origin (the frontend). Since the React app runs on a different port (5173), CORS allows the browser to make secure API calls 
          and include cookies/tokens.

2ï¸âƒ£ Why is credentials: true important?
Answer: It lets browsers send authentication cookies (or JWT tokens) with cross-origin requests. Without it, the server canâ€™t identify logged-in users.

5ï¸âƒ£ What is the use of cookieParser()?
Answer: It parses cookies attached to client requests so they can be accessed via req.cookies. Useful for authentication tokens stored in cookies.

6ï¸âƒ£ How are frontend routes handled in production?
Answer: All non-API routes (*) serve the index.html file from the React build folder, letting React Router handle client-side navigation.

7ï¸âƒ£ What is path.resolve() doing here?
Answer: It returns the absolute path of the current directory (__dirname), which is necessary for serving static files correctly.



********************************************************** 1)authRoutes ******************************************
/signup â†’ Registers new users (usually stores hashed passwords, creates tokens).
/login â†’ Verifies credentials, issues authentication token or cookie.
/logout â†’ Clears session/cookie or invalidates token.
These routes are public (no authentication required).

Protected Routes
router.post("/onboarding", protectRoute, onboard);


protectRoute middleware runs first:
Checks if user is authenticated (usually by decoding JWT).
If valid, attaches user info to req.user.

Then calls onboard controller, which completes user setup (e.g., saving preferences, profile info).


Session Check Route
router.get("/me", protectRoute, (req, res) => {
  res.status(200).json({ success: true, user: req.user });
});

Returns the currently logged-in userâ€™s data.

Useful for restoring sessions (e.g., after page refresh, to auto-login).


| Route                  | Auth Required | HTTP | Description                       |
| ---------------------- | ------------- | ---- | --------------------------------- |
| `/api/auth/signup`     | âŒ             | POST | Register new user                 |
| `/api/auth/login`      | âŒ             | POST | Log user in                       |
| `/api/auth/logout`     | âŒ             | POST | Log user out (clear cookie/token) |
| `/api/auth/onboarding` | âœ…             | POST | Setup user profile after auth     |
| `/api/auth/me`         | âœ…             | GET  | Check if token/session is valid   |



1ï¸âƒ£ What is the role of protectRoute middleware?
Answer:
It checks whether a user is authenticated before allowing access to protected routes. Typically, it:
Reads JWT token from cookies or headers.
Verifies the token with JWT_SECRET.
Attaches decoded user info to req.user.
If verification fails â†’ returns 401 Unauthorized.

5ï¸âƒ£ What does the logout route do internally?
Answer:
Usually clears the cookie storing JWT (using res.clearCookie("token")) or invalidates the token server-side (if stored in DB or cache).
This effectively ends the userâ€™s session.

6ï¸âƒ£ Why use POST for logout instead of GET?
Answer:
Logout changes the serverâ€™s state (removing a session/cookie).
POST is safer than GET (which should be idempotent and not alter state).




âœ… Interview Answer: Explain Your Project in Brief

â€œMy project is a real-time video calling and language-learning social platform called Streamify Video Calls.
It allows users to connect with people worldwide, make friends, and communicate through chat and video calls.
On the backend, I built the system using Node.js, Express, MongoDB, and JWT authentication. The project is structured using the MVC pattern.

Key features I implemented:
1. User Authentication & Onboarding
Secure login and signup using JWT, password hashing with bcrypt,
Users complete onboarding with profile details, languages, and preferences.

2. Stream Video-Call Integration
I integrated Stream API (StreamChat) to generate tokens and upsert users into the Stream platform.
This allows us to enable real-time chat and video calling without managing WebRTC manually.

3. Friend System (Like Social Media)
I built a complete friend-management system:
- Send friend requests
- Accept requests
- Incoming & outgoing requests
- Friend list
- Recommended users (excluding current user & existing friends)

This uses two Mongoose models:
User
FriendRequest

4. Protected Routes & Middleware
All user-related APIs are protected using a custom auth middleware.
Middleware validates the JWT and injects the authenticated user into the request.

5. Clean and Scalable API Architecture
I separated everything into:
Routes
Controllers
Models
Stream utility (stream.js)

This makes the code modular and production-ready.

6. Database Management with MongoDB
Used Mongoose schemas with pre-save hooks (password hashing)
Used $addToSet, $nin, $ne queries for efficient friend recommendation and relationship management

ğŸ¯ Short and impressive version (if interviewer wants very brief)
â€œMy project is a real-time video calling and social interaction platform.
Users can sign up, create profiles, send and accept friend requests, and join video calls using Stream API.
On the backend, I implemented secure authentication, friend management, and Stream token generation using Node.js, Express, MongoDB, and structured everything using the MVC pattern.â€





ğŸ”· 1. Client â†’ Server â†’ Stream API Architecture
Frontend (React/Next.js)
      â†“ HTTP requests (Axios/Fetch)
Backend (Node.js + Express)
      â†“
Controllers â†’ Services â†’ Database (MongoDB)
      â†“
Stream API (for chat + video calls)


â­ Database Schema Design : 1) User, 2) FriendRequest
ğŸ—„ï¸ Database Schema Diagram (High-Level)
Users
 â”œâ”€â”€ _id
 â”œâ”€â”€ fullName
 â”œâ”€â”€ email
 â”œâ”€â”€ password (hashed)
 â”œâ”€â”€ bio
 â”œâ”€â”€ profilePic
 â”œâ”€â”€ nativeLanguage
 â”œâ”€â”€ learningLanguage
 â”œâ”€â”€ location
 â”œâ”€â”€ isOnboarded
 â””â”€â”€ friends â†’ [User._id]

FriendRequests
 â”œâ”€â”€ sender â†’ User._id
 â”œâ”€â”€ recipient â†’ User._id
 â””â”€â”€ status ("pending" | "accepted")


â­ 2. Challenge: Preventing Duplicate Friend Requests
Problem : Users were able to send the same friend request multiple times or even send a request to themselves.

What I did
Added validation to block:
- Self requests
- Requests to existing friends
- Duplicate pending requests

Used MongoDB query:

$or: [
  { sender: myId, recipient: recipientId },
  { sender: recipientId, recipient: myId }
]

Outcome : The friend request system became consistent, clean, and impossible to exploit.




â­ 6. Challenge: Designing Friend Recommendation Logic
Problem => 
Recommended users should exclude:
- The logged-in user
- Already added friends
- Not-yet-onboarded users

What I did

Wrote MongoDB query using:
$ne, $nin, $and

Outcome : The recommendation feature became accurate and efficient.



âœ… Where does your project store chats between friends?
âœ… Your project does NOT store chats in your MongoDB database.
There is no Message model and no custom chat persistence in your backend.
But your project does store chats â€” using Stream (GetStream) Chat API.

ğŸ”¥ Where are chats stored?
ğŸ‘‰ Chats are stored on Streamâ€™s own servers (GetStream Cloud Infrastructure).

StreamChat is a managed real-time messaging platform, so your backend does NOT need to:
âŒ create a message schema
âŒ save messages to MongoDB
âŒ manage chat channels manually

Instead, Stream handles:
âœ” chat history
âœ” channels
âœ” real-time messaging
âœ” user typing indicators
âœ” unread counts
âœ” message persistence
âœ” message search


ğŸ“Œ So the final answer for interview:
â€œWhere are chats stored in your project?â€
All chat messages and chat channels in my Streamify application are stored using the Stream Chat API (GetStream).
My backend only generates Stream user accounts and secure auth tokens.
Stream automatically manages message storage, channels, message history, real-time updates, and scalability on their cloud infrastructure.
So the chat data is not stored in MongoDB â€” it is stored and managed entirely by Stream.â€





ğŸ”„ COMPLETE WORKFLOW OF FRIEND REQUEST SYSTEM

### ğŸ”¹ Step 1: User Sends Friend Request
API: POST /api/users/friend-request/:id

Validations checked:
âœ” Cannot send request to yourself
âœ” Recipient must exist
âœ” Already friends? â†’ reject
âœ” Already a pending request both directions? â†’ reject

If valid â†’ create:
FriendRequest.create({
  sender: myId,
  recipient: recipientId,
  status: "pending"
});


### ğŸ”¹ Step 2: User Receives Pending Requests
API: GET /api/users/friend-requests

Fetches:
incomingReqs = FriendRequest.find({
  recipient: req.user.id,
  status: "pending"
})

âœ” Populates sender profile
âœ” Used to show â€œAccept / Reject Requestâ€ UI


### ğŸ”¹ Step 3: User Accepts Friend Request
API: PUT /api/users/friend-request/:id/accept

Flow:
1ï¸âƒ£ Validate request exists
2ï¸âƒ£ Check current user = recipient
3ï¸âƒ£ Update request status â†’ "accepted"
4ï¸âƒ£ Add EACH USER to the other's friend list:

await User.findByIdAndUpdate(senderId, {
  $addToSet: { friends: recipientId }
});

await User.findByIdAndUpdate(recipientId, {
  $addToSet: { friends: senderId }
});


### ğŸ”¹ Step 4: Store Final Friends List
Once accepted, both users get:
"friends": [ "friendId1", "friendId2", ... ]

This is used in:
âœ” Chat system (show friends available for calls)
âœ” Recommended users (exclude existing friends)
âœ” UI sidebar friend list



âœ… Simple Explanation of How I Implement Video Calls

â€œI added video calling to my project using Streamâ€™s Video API.
Stream works on top of WebRTC â€” which is the technology that actually sends video and audio between two people.
My backend does not handle video directly.
It only creates a Stream token for each user so they can securely join a call.
When a user wants to start or join a call, the frontend uses Streamâ€™s SDK along with this token.
Stream then takes care of the complicated parts like:
- finding and connecting both users
- sharing network details between them
- managing the call room
After Stream finishes this setup, WebRTC ( web Real Time communication) automatically creates a direct peer-to-peer video connection between both users.
This allows smooth and high-quality video and audio communication.â€




âœ… Improvements & New Features I Would Add

â­ 5. Add User Blocking / Reporting
ğŸ”¥ Why? => Prevents harassment and spam.

ğŸ›  How:
Add blockedUsers: [] array in User model.
Modify friend request endpoint to check: if (recipient.blockedUsers.includes(myId)) reject
Add a /block/:id route.


â­ 6. Add Group Calls
ğŸ”¥ Why? => Expands platform usage â†’ group study, team meetings, group chat.

ğŸ›  How:
Use Streamâ€™s "Call Type: default".
Create group rooms with dynamic participant list.
Modify frontend UI to support multiple tiles (grid layout).


â­ 7. Improve Friend Recommendation System
Reason: Right now your recommendation is simple:
â¡ï¸ â€œShow users who are not my friends and not meâ€.

How to Improve:
Add machine learning-based recommendations
Suggest users based on:
Same native/learning language
Same location
Common friends
Interests in bio



âœ… Why didnâ€™t you use WebSockets?
ğŸ¯ Short Version (Perfect for Interviews)
â€œWebSockets are good for real-time messaging, but theyâ€™re not optimized for audio/video streaming.
Since my project involved video calls, I used Stream API, which internally handles WebRTC, scalability, and security, saving development time and complexity.â€

ğŸ’¡ Bonus Line (Very Impressive)
â€œIf the project only required simple chat or notifications, WebSockets would be enough. But for real-time video communication at scale, 
a managed solution like Stream is more reliable.â€




âœ… Interview Answer: Explain Your Project in Brief
â€œConnectPro is a real-time chat and video calling platform designed for language exchange.
It allows users to connect with people worldwide, make friends, and communicate through chat and video calls.
On the frontend, I used React with Tailwind CSS.
On the backend, I built the system using Node.js, Express and MongoDB for data storage.
I implemented secure user authentication using JWT and bcrypt, along with profile onboarding.
For real-time chat and video calling, I integrated the Stream API to handle token generation and user management.
I also implemented a friend management system similar to social media platforms where users can send, receive, and accept friend requests.
// Friend recommendations are generated by filtering existing friends and pending requests efficiently using MongoDB queries.
I protected all APIs using custom authentication middleware.
The project is modular, scalable and responsive for different device size.â€



ğŸ”´ Challenges Faced in the Project
1. Real-time Communication Integration
Integrating real-time chat and video calling was challenging because handling WebRTC directly is complex.
To solve this, I integrated the Stream API, which required proper token generation, user synchronization, and secure backend handling.

2. Secure Authentication & Authorization
Implementing JWT-based authentication with protected routes was challenging, especially ensuring token validation across multiple APIs.
I solved this by creating a reusable authentication middleware that injects the authenticated user into every request.

3. Friend Request & Recommendation Logic
Designing the friend system was tricky due to multiple states like pending, accepted, outgoing, and incoming requests.
I used optimized MongoDB queries like $addToSet, $nin, and $ne to handle this efficiently.

4. Database Relationship Management
Maintaining clean relationships between users and friend requests without duplication required careful schema design and indexing.

5. Scalability & Clean Architecture
Ensuring the project stayed modular and scalable was challenging as features grew.
I addressed this by strictly following the MVC pattern and separating business logic into controllers and utilities.


ğŸŸ¢ What Would You Improve If Given More Time?
1. Real-time Notifications
I would add WebSocket-based notifications for friend requests, acceptances, and missed calls.

2. Better Recommendation Algorithm
Improve friend recommendations using mutual friends, language similarity, and activity history instead of simple filtering.

3. Performance Optimization
Add Redis caching for frequently accessed data like friend lists and user profiles to reduce database load.

4. Advanced Security Features
Implement refresh tokens, rate limiting, and API request throttling for enhanced security.




âœ… What is JWT (JSON Web Token)?
JWT is a stateless, secure way to transmit user identity information between a client and a server.
It is mainly used for authentication and authorization in web applications.

A JWT is a compact string made of three parts: Header.Payload.Signature

âœ… Why do we use JWT?
To authenticate users after login
To protect APIs (authorization)
To avoid server-side session storage
To scale applications easily

JWT is stateless, meaning the server does not store session data.

âœ… Structure of JWT

Header:
Algorithm used (HS256 / RS256)
Token type (JWT)

Payload:
User data (claims) like: userId, role, email
Expiry time (exp)

Signature:
Created using: base64(header + payload + secretKey)
Prevents token tampering


âœ… JWT Authentication Workflow (Step-by-Step)
ğŸ”¹ 1. User Login
User sends email & password to backend
Backend validates credentials

ğŸ”¹ 2. Token Generation
Backend generates JWT using: User ID, Role, Expiry time
Token is signed with a secret key

ğŸ”¹ 3. Token Sent to Client
JWT is returned to frontend
Stored in: HttpOnly Cookie (more secure) OR LocalStorage

ğŸ”¹ 4. Accessing Protected Routes
Frontend sends JWT in every request:
Authorization: Bearer <token>

ğŸ”¹ 5. Token Verification (Middleware)
Backend middleware:
Extracts token
Verifies signature
Checks expiry

If valid â†’ request allowed
If invalid/expired â†’ 401 Unauthorized

ğŸ”¹ 6. Authorization
Backend checks role from payload

Grants or denies access (e.g., admin vs user)


âœ… JWT Example Flow (Simple)
Login â†’ JWT Generated â†’ Token Stored in cookies â†’ Token Sent with Requests â†’ Middleware Verifies â†’ User Gets Access

âœ… Advantages of JWT
Stateless & scalable
Faster authentication
Works well with microservices
Easy frontend-backend integration

âš ï¸ Limitations of JWT
Cannot be easily invalidated before expiry
Token theft = security risk
Needs HTTPS always

âœ… JWT in Your Project (Interview Tie-in)
â€œIn my project, I use JWT for user authentication. After login, the server generates a token and sends it to the frontend. For every protected API, 
I validate the token using middleware before allowing access.â€

ğŸ¯ Short Interview Answer (Best)
â€œJWT is a stateless authentication mechanism used to securely transmit user identity. After login, the server generates a signed token and sends it to the client. 
The client sends this token with every request, and the backend verifies it using middleware before allowing access.â€

ğŸ’¡ Bonus Line (Impressive)
â€œJWT shifts authentication responsibility to the client while keeping the server stateless.â€
