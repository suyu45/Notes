| **Feature**              | **C Language**                                                   | **C++ Language**                                                          |
| ------------------------ | ---------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **Programming Paradigm** | Procedure-oriented / Structure-oriented                          | Both Procedure-oriented and Object-oriented                               |
| **Approach**             | Top-down approach                                                | Bottom-up + OOP approach                                                  |
| **Relationship**         | Base language                                                    | Incremental version of C                                                  |
| **File Extension**       | `.c`                                                             | `.cpp`                                                                    |
| **Overloading**          | Function and operator overloading **not supported**              | Function and operator overloading **supported**                           |
| **Variable Declaration** | Local variables must be declared at the **beginning of a block** | Variables can be declared **inline**, wherever needed                     |
| **Emphasis**             | More emphasis on **procedures**                                  | More emphasis on **data**                                                 |
| **OOP Features**         | No polymorphism, encapsulation, or inheritance                   | Supports polymorphism, encapsulation, and inheritance                     |
| **Data Abstraction**     | **Not supported**                                                | **Supported**                                                             |
| **Data Security**        | Data is open; any function can access it                         | Access controlled using **visibility modes** (public, private, protected) |
| **Dynamic Binding**      | Not supported                                                    | Supported                                                                 |
| **Modularity**           | Uses functions and subprograms                                   | Uses classes, objects, functions                                          |
| **Compatibility**        | C code runs in C++                                               | C++ code may not run in C                                                 |
| **Control Structures**   | Jump statements and subroutine calls                             | Supports all C features plus OOP structures                               |
| **Data Handling**        | Data is globally accessible                                      | Provides **data hiding** and security                                     |


variables => global, local
operators => Arithmetic, Logical (Comparison), Assignment, Bitwise
break, continue
Switch Statements
ternary operator ( if-else ) => ? :
call by value, call by reference
call by pointer
ampersand (&) operator which denotes an address in memory. 
*(address) ===>  (*) is de-referancing operator which gives value

pointer =>  int *p = &a;  int **pp;     char*ch // pointer to character
A pointer is a variable that holds the memory address of another variable.
It is used to access and manipulate data indirectly through its address.
ğŸ“Œ Why do we use pointers?
Pointers allow:
Dynamic memory allocation (new, delete)
Efficient array & string operations
Passing large objects to functions without copying
Implementing data structures (linked list, trees, graph)
Polymorphism (using base class pointers)

| Operator | Description                                                   |
| -------- | ------------------------------------------------------------- |
| `&`      | Address-of operator (gives address of variable)               |
| `*`      | Dereference operator (access value stored at pointer address) |





****************************************** shallow and deep copy ***************************************
â­ Shallow Copy vs Deep Copy
Shallow and deep copy refer to how objects are copied in object-oriented programming.

âœ… Shallow Copy (Default Copy)
âœ” What it does:
Copies only the values of data members.
For pointers â†’ it copies the address, not the data stored at that address.
Both objects now point to the same memory.

âŒ Problem:
If one object modifies the pointer data â†’ the other object is affected.
When destructors run â†’ double free error may occur.

âœ” Created by:
Default copy constructor
Default assignment operator

ğŸ”¹ Shallow Copy Example

class Demo {
public:
    int *ptr;

    Demo(int x) {
        ptr = new int(x);
    }
};

int main() {
    Demo d1(10);
    Demo d2 = d1;   // shallow copy

    *d2.ptr = 20;   // modifying d2

    cout << *d1.ptr << endl;  // Output: 20 (affected!)
}

ğŸ” Explanation:
d1.ptr and d2.ptr point to the same memory â†’ unsafe.


âœ… Deep Copy
âœ” What it does:
Copies data and allocates new memory.
For pointer members â†’ it creates a separate copy.
Objects become independent.

âœ” Use deep copy when:
Your class contains dynamic memory
You want independent objects

ğŸ”¹ Deep Copy Example with Custom Copy Constructor

class Demo {
public:
    int *ptr;

    Demo(int x) {
        ptr = new int(x);
    }

    // Deep copy constructor
    Demo(const Demo &d) {
        ptr = new int(*d.ptr);   // allocate new memory
    }
};

int main() {
    Demo d1(10);
    Demo d2 = d1;   // deep copy now

    *d2.ptr = 20;

    cout << *d1.ptr << endl;   // Output: 10 (not affected)
    cout << *d2.ptr << endl;   // Output: 20
}

ğŸ§  Key Differences
| Feature             | Shallow Copy                           | Deep Copy                   |
| ------------------- | -------------------------------------- | --------------------------- |
| Pointer behavior    | Copies pointer address                 | Copies actual data          |
| Memory              | Shared memory                          | Separate memory             |
| Safety              | Unsafe (double free, unwanted changes) | Safe                        |
| Default by compiler | Yes                                    | No (needs custom code)      |
| Use case            | Simple objects                         | Objects with dynamic memory |

ğŸ One-Line Interview Answer
Shallow copy copies only the address of dynamically allocated memory, while deep copy creates a new memory block and copies data so both objects are independent.





| **Feature**           | **Procedure Oriented Programming (POP)** | **Object Oriented Programming (OOP)**        |
| --------------------- | ---------------------------------------- | -------------------------------------------- |
| **Program Structure** | Divided into **functions**               | objects=> contain data & functions together. |
| **Focus**             | On **functions & procedures**            | On **data & objects**                        |
| **Approach**          | **Top-Down**                             | **Bottom-Up**                                |
| **Access Specifiers** | Not available                            | Public, Private, Protected                   |
| **Data Movement**     | Data moves freely between functions      | Data stays inside objects; controlled access |
| **Data Sharing**      | Uses global data; easily accessible      | Data is protected using access specifiers    |
| **Security**          | Less secure, no data hiding              | Highly secure due to data hiding             |
| **Extensibility**     | Hard to add new data/functions           | Easy to extend with new data/functions       |
| **Overloading**       | Not supported                            | Supported (function & operator overloading)  |
| **Examples**          | C, VB, FORTRAN, Pascal                   | C++, Java, VB.NET, C#.NET                    |



â­ What is a Static Variable?
A static variable is a variable whose lifetime lasts for the entire program.
It is created only once and retains its value between function calls.

Static variables can be used:
Inside functions
Inside classes (as static data member)
As global static variables (file-level scope)

ğŸ§  Key Properties of Static Variables
âœ” 1. Memory is allocated only once
Static variables are stored in the static/global memory area, not on the stack.

âœ” 2. Retains value between function calls
A normal (auto) variable is re-created every time a function is called.
A static variable keeps its updated value.

âœ” 3. Default value = 0
If uninitialized, static variables automatically get 0.

âœ” 4. Scope may be local, but lifetime is global
Static variable inside a function is local in scope but global in lifetime.

ğŸ“Œ Example 1: Static Variable in a Function

void counter() {
    static int count = 0;   // created once, retains value
    count++;
    cout << "Count = " << count << endl;
}

int main() {
    counter();
    counter();
    counter();
    return 0;
}

Output
Count = 1
Count = 2
Count = 3

ğŸ‘‰ Normal variable would reset to 0 each time, but static variable remembers the value.

ğŸ¯ Short Interview Answer
A static variable is a variable that is created once and retains its value for the entire program lifetime.
It is stored in static memory and keeps its value between function calls.
In classes, static variables are shared by all objects.

***************************************************************************************************************************************************


â­ Static Data Member (Static Variable in Class)
A static data member is a variable that:
Belongs to the class, not to any object.
Has only one copy shared by all objects.
Is stored in static memory (not inside each object).
Must be defined outside the class.
Can be accessed using class name as well as object.

ğŸ‘‰ Why use static data member?
To store information common to all objects (e.g., count of objects).

******************************************
âœ” Example: Static Data Member

class Student {
public:
    static int count;   // declaration
    string name;

    Student(string n) {
        name = n;
        count++;        // increment object count
    }
};

// definition outside class
int Student::count = 0;

int main() {
    Student s1("Amit");
    Student s2("Suman");

    cout << "Total students: " << Student::count;  // accessing with class name
    return 0;
}

Output:
Total students: 2
******************************************


â­ Static Member Function
A static member function:
Can access only static data members.
Does not have this pointer (because it doesnâ€™t belong to any object).

Can be called using:
Class name (recommended)
Object name (allowed but not preferred)

****************************************
âœ” Example: Static Member Function

class Student {
public:
    static int count;   // static data member

    // Constructor increments count whenever object is created
    Student() {
        count++;
    }

    static void getCount() {
        cout << "Total objects created: " << count << endl;
    }
};

// definition of static member
int Student::count = 0;

int main() {

    Student::getCount();   // Before any object creation â†’ 0

    Student s1;
    Student s2;
    Student s3;

    Student::getCount();   // After creating 3 objects â†’ 3

    return 0;
}

ğŸ“¤ Output
Total objects created: 0
Total objects created: 3
****************************************

ğŸ¯ Short Interview Answer
Static data members belong to the class, not objects, so all objects share a single copy.
Static member functions also belong to the class and can only access static members.

******************************************************************************************************************************************************************************




â­ What is a Friend Class?
A friend class is a class that is allowed to access private and protected members of another class.
ğŸ‘‰ Normally, private members cannot be accessed outside the class.
ğŸ‘‰ But if Class A declares Class B as a friend, then Class B can access Aâ€™s private data.

ğŸ§  Key Points of Friend Class
âœ” Allows one class to access another class's private/protected members
âœ” Declared using: friend class ClassName;
âœ” Useful when classes need to work closely together
âœ” Breaks encapsulation â†’ use only when required
âœ” Friendship is not inherited and not reciprocal

â­ 1. Real-World Example of Friend Class
ğŸ“Œ Scenario: Bank & Auditor
A Bank class stores sensitive data like: account balance, transactions, customer details
This data is private and not accessible to anyone.
But an Auditor class must access all private details for auditing.
So we make Auditor a friend class of Bank.

âœ” Real-World Code Example (Friend Class)

class Bank {
private:
    string name;
    double balance;

    // Auditor needs to check private data
    friend class Auditor; // ******** v v imp *********

public:
    Bank(string n, double b) : name(n), balance(b) {}
};

class Auditor {
public:
    void auditReport(Bank b) {
        cout << "Auditing Account of: " << b.name << endl;
        cout << "Balance: â‚¹" << b.balance << endl;
    }
};

int main() {
    Bank customer("Rahul", 50000.0);
    Auditor a;

    a.auditReport(customer);

    return 0;
}

ğŸ¯ Why itâ€™s Real-World?
Auditors are authorized to check confidential data that normal employees can't â€” this matches friend class behavior.

â­ Why Use a Friend Class?
When two classes need tight coupling
To allow helper/utility classes to access private data

Commonly used in:
âœ” Operator overloading between two classes
âœ” Complex data structures (like Linked List, Tree, Graph implementation)

ğŸ¯ Short Interview Answer
A friend class is a class that can access the private and protected members of another class.
It is declared using the friend class keyword.
It helps when two classes need to work closely and share internal data.

******************************************************************************************************************************************************************************


â­ What is a Friend Function in C++?
A friend function is a function that is not a member of a class but is allowed to access its private and protected members.
You declare it using the keyword: friend
It helps when two classes or external functions need access to internal (private) data.

ğŸ§  Key Points
âœ” Not a member of the class
âœ” Has access to private & protected data
âœ” Declared inside the class using friend keyword
âœ” Defined normally like a non-member function
âœ” Can be a:
Simple friend function
Friend of multiple classes
Friend class

âœ” Example 1: Simple Friend Function

class Student {
private:
    int marks;

public:
    Student(int m) {
        marks = m;
    }

    // Friend function declaration
    friend void showMarks(Student s);
};

// Friend function definition
void showMarks(Student s) {
    cout << "Marks: " << s.marks << endl;  // Accessing private member
}

int main() {
    Student s(95);
    showMarks(s);
    return 0;
}

Output
Marks: 95

â­ 2. Real-World Example of Friend Function
ğŸ“Œ Scenario: Two Companies Sharing Private Data for Merger
Company A and Company B are planning a merger.
They both keep revenue private but need a special merger function to access private data from both.
This merging calculation requires: Company Aâ€™s private revenue, Company Bâ€™s private revenue
So we use a friend function.

âœ” Example 2: Friend Function Accessing Two Classes
Used when a function must access private data of multiple classes.

âœ” Real-World Code Example (Friend Function)

class CompanyB; // forward declaration

class CompanyA {
private:
    int revenueA;

public:
    CompanyA(int r) : revenueA(r) {}

    // friend function declaration
    friend void mergerReport(CompanyA, CompanyB);
};

class CompanyB {
private:
    int revenueB;

public:
    CompanyB(int r) : revenueB(r) {}

    // friend declaration for same function
    friend void mergerReport(CompanyA, CompanyB);
};

void mergerReport(CompanyA a, CompanyB b) {
    cout << "Total Combined Revenue: " << (a.revenueA + b.revenueB) << " Million" << endl;
}

int main() {
    CompanyA a(120);
    CompanyB b(180);

    mergerReport(a, b);

    return 0;
}

ğŸ¤ Short Interview Answer
A friend function is a non-member function that can access private and protected members of a class.
It is declared inside the class using the friend keyword.
It is commonly used in operator overloading and when two classes need to share private data.

ğŸ§  One-Line Interview Answers
âœ” Friend Class:
A friend class is a class that can access private data of another class.
Example: Auditor class accessing private bank account details.

âœ” Friend Function:
A friend function is a non-member function that can access private data of one or more classes.
Example: Merger function accessing private revenue data of two companies.



ğŸ¯ Example: Operator + Overloading Using Friend Function

We will overload + to add two objects of class Complex.

âœ” Code Example
#include <iostream>
using namespace std;

class Complex {
private:
    int real, imag;

public:
    Complex(int r = 0, int i = 0) {
        real = r;
        imag = i;
    }

    // Declare friend function
    friend Complex operator + (Complex c1, Complex c2);

    void display() {
        cout << real << " + " << imag << "i" << endl;
    }
};

// Friend function definition
Complex operator + (Complex c1, Complex c2) {
    Complex temp;
    temp.real = c1.real + c2.real;
    temp.imag = c1.imag + c2.imag;
    return temp;
}

int main() {
    Complex a(5, 3);
    Complex b(2, 4);

    Complex c = a + b;   // Calls friend operator+

    c.display();
    return 0;
}

ğŸ“¤ Output
7 + 7i


******************************************************************************************************************************************************************************

â­ What is a Virtual Function?
A virtual function is a function in the base class that is redefined in the derived class and supports runtime polymorphism (dynamic binding).
It ensures that the function of the derived class is called, even when you use a base class pointer.

ğŸ¯ Why Do We Use Virtual Functions?
Because using a base class pointer normally calls the base class version, not the derived version.

Virtual functions allow us to achieve:
âœ” Runtime polymorphism
âœ” Dynamic binding
âœ” Method overriding

ğŸ§  Key Points
Declared using the keyword virtual
Must be a member function of a class
Invoked through base class pointers
Works during runtime (late binding)
Helps implement polymorphism & abstraction

âœ” Simple Example of Virtual Function

class Animal {
public:
    virtual void sound() {     // virtual function
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {    // overriding
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* a;   // base class pointer
    Dog d;

    a = &d;     // pointer holding object of derived class

    a->sound(); // calls Dog's sound() because of virtual function

    return 0;
}

ğŸ“¤ Output
Dog barks


ğŸ§© How It Works (Simple Explanation)
Without virtual:
â¡ Base class pointer â†’ Base class function

With virtual:
â¡ Base class pointer â†’ Derived class function

This is runtime polymorphism.

â­ Real-world Analogy
Base class: Remote â†’ has a general function â€œpressPower()â€
Derived class: TV Remote, AC Remote, Fan Remote
When you press the power button (call function), the behavior depends on which remote youâ€™re holding, not on the â€œRemote classâ€.

Virtual function ensures:
ğŸ‘‰ The correct device turns ON based on the object type.

âœ” More Detailed Example (Multiple Derived Classes)
class Shape {
public:
    virtual void draw() {
        cout << "Drawing Shape" << endl;
    }
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing Circle" << endl;
    }
};

class Square : public Shape {
public:
    void draw() override {
        cout << "Drawing Square" << endl;
    }
};

ğŸ”¥ Short Interview Answer (10 Seconds)
A virtual function is a function in a base class that can be overridden in derived classes and supports runtime polymorphism.
It ensures that the derived class version is executed when a base class pointer is used.

******************************************************************************************************************************************************************************

â­ What is a Pure Virtual Function?
A pure virtual function is a virtual function that has no definition in the base class and must be overridden in the derived class.
It makes the base class abstract, meaning you cannot create objects of that class.

âœ… Definition
A pure virtual function is declared using:     virtual void functionName() = 0;

ğŸ¯ Why use Pure Virtual Function?
To create a common interface for all derived classes.
To ensure every derived class provides its own implementation.
To support runtime polymorphism.

âœ… Example: Pure Virtual Function in Real Use (Shape Example)
ğŸ‘‰ Base class Shape defines a pure virtual function area()
Every shape must implement its own formula.

class Shape {
public:
    // Pure virtual function
    virtual float area() = 0;
};

ğŸ‘‰ Derived class 1: Rectangle
class Rectangle : public Shape {
    float length, width;
public:
    Rectangle(float l, float w) {
        length = l;
        width = w;
    }

    float area() {
        return length * width;
    }
};

ğŸ‘‰ Derived class 2: Circle
class Circle : public Shape {
    float radius;
public:
    Circle(float r) {
        radius = r;
    }

    float area() {
        return 3.14 * radius * radius;
    }
};

ğŸ‘‰ Using polymorphism
int main() {
    Shape *s;

    Rectangle r(5, 4);
    Circle c(3);

    s = &r;
    cout << "Rectangle Area: " << s->area() << endl;

    s = &c;
    cout << "Circle Area: " << s->area() << endl;

    return 0;
}

ğŸ“ Output
Rectangle Area: 20
Circle Area: 28.26

â­ Key Points to Remember
âœ” Makes class abstract => A class with at least one pure virtual function is an abstract class.
âœ” Cannot create object of abstract class => Shape s; // âŒ Not allowed
âœ” Forces derived classes to override function => Each child class must implement area().

ğŸ¯ Real-World Example
Think of a "Payment" interface:
Every payment method must implement processPayment().
But base class cannot define it because each system is different.


*******************************************************************************************************************************************

â­ What is a Abstract class?
An abstract class in C++ is a class that cannot be instantiated and is meant to be used only as a base class.
It contains at least one pure virtual function.
It provides a blueprint/interface for derived classes.
âœ” Cannot create objects of abstract class

âœ… Definition
A class becomes abstract when it has one or more pure virtual functions:

class Base {
public:
    virtual void display() = 0;   // pure virtual function
};

ğŸ¯ Why use Abstract Classes?
To define a common interface for all child classes.
To enforce that derived classes must implement certain methods.
To support runtime polymorphism.
To separate what to do (base class) from how to do (derived class).

â­ Key Features of Abstract Class
âœ” Has at least one pure virtual function => virtual void show() = 0;
âœ” Cannot create objects of abstract class => Shape s;   // âŒ Not allowed
âœ” Used when different classes must follow the same interface
(Example: "Print()", "Area()", "Draw()", "Login()")

ğŸ¯ Real-Life Example: Payment System
ğŸ‘‰ Abstract class
class Payment {
public:
    virtual void pay(int amount) = 0;
};

ğŸ‘‰ Derived classes implement it differently
class UPI : public Payment {
public:
    void pay(int amount) {
        cout << "Paid Rs." << amount << " using UPI" << endl;
    }
};

class Card : public Payment {
public:
    void pay(int amount) {
        cout << "Paid Rs." << amount << " using Card" << endl;
    }
};

ğŸš€ When to Use Abstract Classes?
Use an abstract class when:
- You want to define a common interface.
- You want derived classes to implement required functions.
- You want to use polymorphism.




*********************************************************************************************************************************************

â­ What is Interface ?
In C++, there is no keyword called interface like in Java or C#.
But you can create an interface using an abstract class that has:
âœ… Only pure virtual functions
âœ… No data members (usually)
Such a class acts exactly like an interface.

â­ Definition (C++ Interface)
A C++ interface is an abstract class where:
All functions are pure virtual
It defines what needs to be done, not how

class InterfaceName {
public:
    virtual void function1() = 0;
    virtual void function2() = 0;
};

ğŸ¯ Why Interfaces?
Interfaces achieve: 100% abstraction, Loose coupling, Multiple inheritance, Common behavior structure

ğŸ§© Example: Interface for "Drive" Behavior
ğŸ‘‰ Interface
class Vehicle {
public:
    virtual void start() = 0;
    virtual void stop() = 0;
};

ğŸ‘‰ Car implements the interface
class Car : public Vehicle {
public:
    void start() {
        cout << "Car started" << endl;
    }
    void stop() {
        cout << "Car stopped" << endl;
    }
};

ğŸ‘‰ Bike implements the interface
class Bike : public Vehicle {
public:
    void start() {
        cout << "Bike started" << endl;
    }
    void stop() {
        cout << "Bike stopped" << endl;
    }
};

â–¶ Usage with Polymorphism
int main() {
    Vehicle* v;

    Car c;
    Bike b;

    v = &c;
    v->start();
    v->stop();

    v = &b;
    v->start();
    v->stop();

    return 0;
}

ğŸ“ Output
Car started
Car stopped
Bike started
Bike stopped

ğŸ Summary
An interface in C++ is created using an abstract class with only pure virtual functions.
It is used when multiple classes must follow the same common rules/structure but implement it in their own way.


ğŸ§© Comparison Table
| Feature                       | Abstract Class               | Interface (C++)              |
| ----------------------------- | ---------------------------- | ---------------------------- |
| Contains normal methods       | âœ” Yes                        | âŒ No                         |
| Contains pure virtual methods | âœ” Yes                        | âœ” Yes (must be all)          |
| Can have data members         | âœ” Yes                        | âŒ No (generally not allowed) |
| Constructors allowed          | âœ” Yes                        | âŒ Rarely used (no need)      |
| Supports multiple inheritance | âœ” Yes                        | âœ” Yes                        |
| Level of abstraction          | Partial abstraction          | Full (100%) abstraction      |
| Can provide default behavior  | âœ” Yes                        | âŒ No                         |
| When to use?                  | When some behavior is common | When defining rules/contract |


2ï¸âƒ£ Abstract Class Example => Contains a pure virtual function + normal function.

class Animal {
public:
    virtual void sound() = 0;     // pure virtual
    void eat() {                   // normal function
        cout << "This animal eats food.\n";
    }
};


ğŸ“˜ Real-World Analogy
Interface = Rules / Contract
Example: Driving License
- Defines what you must do (drive, follow rules)
- Does not tell how you should drive
- Anyone (car, bike, truck) can implement it

Abstract Class = Base Blueprint
Example: Vehicle
- Has wheels, engine (shared properties)
- Some functions defined, some not

ğŸ Summary (One-Liner for Interview)
Abstract class = Partial abstraction + common behavior
Interface = 100% abstraction + only rules, no implementation

