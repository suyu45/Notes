| **Feature**              | **C Language**                                                   | **C++ Language**                                                          |
| ------------------------ | ---------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **Programming Paradigm** | Procedure-oriented / Structure-oriented                          | Both Procedure-oriented and Object-oriented                               |
| **Approach**             | Top-down approach                                                | Bottom-up + OOP approach                                                  |
| **Relationship**         | Base language                                                    | Incremental version of C                                                  |
| **File Extension**       | `.c`                                                             | `.cpp`                                                                    |
| **Overloading**          | Function and operator overloading **not supported**              | Function and operator overloading **supported**                           |
| **Variable Declaration** | Local variables must be declared at the **beginning of a block** | Variables can be declared **inline**, wherever needed                     |
| **Emphasis**             | More emphasis on **procedures**                                  | More emphasis on **data**                                                 |
| **OOP Features**         | No polymorphism, encapsulation, or inheritance                   | Supports polymorphism, encapsulation, and inheritance                     |
| **Data Abstraction**     | **Not supported**                                                | **Supported**                                                             |
| **Data Security**        | Data is open; any function can access it                         | Access controlled using **visibility modes** (public, private, protected) |
| **Dynamic Binding**      | Not supported                                                    | Supported                                                                 |
| **Modularity**           | Uses functions and subprograms                                   | Uses classes, objects, functions                                          |
| **Compatibility**        | C code runs in C++                                               | C++ code may not run in C                                                 |
| **Control Structures**   | Jump statements and subroutine calls                             | Supports all C features plus OOP structures                               |
| **Data Handling**        | Data is globally accessible                                      | Provides **data hiding** and security                                     |





| **Feature**           | **Procedure Oriented Programming (POP)** | **Object Oriented Programming (OOP)**        |
| --------------------- | ---------------------------------------- | -------------------------------------------- |
| **Program Structure** | Divided into **functions**               | objects=> contain data & functions together. |
| **Focus**             | On **functions & procedures**            | On **data & objects**                        |
| **Approach**          | **Top-Down**                             | **Bottom-Up**                                |
| **Access Specifiers** | Not available                            | Public, Private, Protected                   |
| **Data Movement**     | Data moves freely between functions      | Data stays inside objects; controlled access |
| **Data Sharing**      | Uses global data; easily accessible      | Data is protected using access specifiers    |
| **Security**          | Less secure, no data hiding              | Highly secure due to data hiding             |
| **Extensibility**     | Hard to add new data/functions           | Easy to extend with new data/functions       |
| **Overloading**       | Not supported                            | Supported (function & operator overloading)  |
| **Examples**          | C, VB, FORTRAN, Pascal                   | C++, Java, VB.NET, C#.NET                    |



‚≠ê What is a Static Variable?
A static variable is a variable whose lifetime lasts for the entire program.
It is created only once and retains its value between function calls.

Static variables can be used:
Inside functions
Inside classes (as static data member)
As global static variables (file-level scope)

üß† Key Properties of Static Variables
‚úî 1. Memory is allocated only once
Static variables are stored in the static/global memory area, not on the stack.

‚úî 2. Retains value between function calls
A normal (auto) variable is re-created every time a function is called.
A static variable keeps its updated value.

‚úî 3. Default value = 0
If uninitialized, static variables automatically get 0.

‚úî 4. Scope may be local, but lifetime is global
Static variable inside a function is local in scope but global in lifetime.

üìå Example 1: Static Variable in a Function

void counter() {
    static int count = 0;   // created once, retains value
    count++;
    cout << "Count = " << count << endl;
}

int main() {
    counter();
    counter();
    counter();
    return 0;
}

Output
Count = 1
Count = 2
Count = 3

üëâ Normal variable would reset to 0 each time, but static variable remembers the value.

üéØ Short Interview Answer
A static variable is a variable that is created once and retains its value for the entire program lifetime.
It is stored in static memory and keeps its value between function calls.
In classes, static variables are shared by all objects.

***************************************************************************************************************************************************


‚≠ê Static Data Member (Static Variable in Class)
A static data member is a variable that:
Belongs to the class, not to any object.
Has only one copy shared by all objects.
Is stored in static memory (not inside each object).
Must be defined outside the class.
Can be accessed using class name as well as object.

üëâ Why use static data member?
To store information common to all objects (e.g., count of objects).

******************************************
‚úî Example: Static Data Member

class Student {
public:
    static int count;   // declaration
    string name;

    Student(string n) {
        name = n;
        count++;        // increment object count
    }
};

// definition outside class
int Student::count = 0;

int main() {
    Student s1("Amit");
    Student s2("Suman");

    cout << "Total students: " << Student::count;  // accessing with class name
    return 0;
}

Output:
Total students: 2
******************************************


‚≠ê Static Member Function
A static member function:
Can access only static data members.
Does not have this pointer (because it doesn‚Äôt belong to any object).

Can be called using:
Class name (recommended)
Object name (allowed but not preferred)

****************************************
‚úî Example: Static Member Function

class Student {
public:
    static int count;   // static data member

    // Constructor increments count whenever object is created
    Student() {
        count++;
    }

    static void getCount() {
        cout << "Total objects created: " << count << endl;
    }
};

// definition of static member
int Student::count = 0;

int main() {

    Student::getCount();   // Before any object creation ‚Üí 0

    Student s1;
    Student s2;
    Student s3;

    Student::getCount();   // After creating 3 objects ‚Üí 3

    return 0;
}

üì§ Output
Total objects created: 0
Total objects created: 3
****************************************

üéØ Short Interview Answer
Static data members belong to the class, not objects, so all objects share a single copy.
Static member functions also belong to the class and can only access static members.

******************************************************************************************************************************************************************************




‚≠ê What is a Friend Class?
A friend class is a class that is allowed to access private and protected members of another class.
üëâ Normally, private members cannot be accessed outside the class.
üëâ But if Class A declares Class B as a friend, then Class B can access A‚Äôs private data.

üß† Key Points of Friend Class
‚úî Allows one class to access another class's private/protected members
‚úî Declared using: friend class ClassName;
‚úî Useful when classes need to work closely together
‚úî Breaks encapsulation ‚Üí use only when required
‚úî Friendship is not inherited and not reciprocal

‚≠ê 1. Real-World Example of Friend Class
üìå Scenario: Bank & Auditor
A Bank class stores sensitive data like: account balance, transactions, customer details
This data is private and not accessible to anyone.
But an Auditor class must access all private details for auditing.
So we make Auditor a friend class of Bank.

‚úî Real-World Code Example (Friend Class)

class Bank {
private:
    string name;
    double balance;

    // Auditor needs to check private data
    friend class Auditor; // ******** v v imp *********

public:
    Bank(string n, double b) : name(n), balance(b) {}
};

class Auditor {
public:
    void auditReport(Bank b) {
        cout << "Auditing Account of: " << b.name << endl;
        cout << "Balance: ‚Çπ" << b.balance << endl;
    }
};

int main() {
    Bank customer("Rahul", 50000.0);
    Auditor a;

    a.auditReport(customer);

    return 0;
}

üéØ Why it‚Äôs Real-World?
Auditors are authorized to check confidential data that normal employees can't ‚Äî this matches friend class behavior.

‚≠ê Why Use a Friend Class?
When two classes need tight coupling
To allow helper/utility classes to access private data

Commonly used in:
‚úî Operator overloading between two classes
‚úî Complex data structures (like Linked List, Tree, Graph implementation)

üéØ Short Interview Answer
A friend class is a class that can access the private and protected members of another class.
It is declared using the friend class keyword.
It helps when two classes need to work closely and share internal data.

******************************************************************************************************************************************************************************


‚≠ê What is a Friend Function in C++?
A friend function is a function that is not a member of a class but is allowed to access its private and protected members.
You declare it using the keyword: friend
It helps when two classes or external functions need access to internal (private) data.

üß† Key Points
‚úî Not a member of the class
‚úî Has access to private & protected data
‚úî Declared inside the class using friend keyword
‚úî Defined normally like a non-member function
‚úî Can be a:
Simple friend function
Friend of multiple classes
Friend class

‚úî Example 1: Simple Friend Function

class Student {
private:
    int marks;

public:
    Student(int m) {
        marks = m;
    }

    // Friend function declaration
    friend void showMarks(Student s);
};

// Friend function definition
void showMarks(Student s) {
    cout << "Marks: " << s.marks << endl;  // Accessing private member
}

int main() {
    Student s(95);
    showMarks(s);
    return 0;
}

Output
Marks: 95

‚≠ê 2. Real-World Example of Friend Function
üìå Scenario: Two Companies Sharing Private Data for Merger
Company A and Company B are planning a merger.
They both keep revenue private but need a special merger function to access private data from both.
This merging calculation requires: Company A‚Äôs private revenue, Company B‚Äôs private revenue
So we use a friend function.

‚úî Example 2: Friend Function Accessing Two Classes
Used when a function must access private data of multiple classes.

‚úî Real-World Code Example (Friend Function)

class CompanyB; // forward declaration

class CompanyA {
private:
    int revenueA;

public:
    CompanyA(int r) : revenueA(r) {}

    // friend function declaration
    friend void mergerReport(CompanyA, CompanyB);
};

class CompanyB {
private:
    int revenueB;

public:
    CompanyB(int r) : revenueB(r) {}

    // friend declaration for same function
    friend void mergerReport(CompanyA, CompanyB);
};

void mergerReport(CompanyA a, CompanyB b) {
    cout << "Total Combined Revenue: " << (a.revenueA + b.revenueB) << " Million" << endl;
}

int main() {
    CompanyA a(120);
    CompanyB b(180);

    mergerReport(a, b);

    return 0;
}

üé§ Short Interview Answer
A friend function is a non-member function that can access private and protected members of a class.
It is declared inside the class using the friend keyword.
It is commonly used in operator overloading and when two classes need to share private data.

üß† One-Line Interview Answers
‚úî Friend Class:
A friend class is a class that can access private data of another class.
Example: Auditor class accessing private bank account details.

‚úî Friend Function:
A friend function is a non-member function that can access private data of one or more classes.
Example: Merger function accessing private revenue data of two companies.



üéØ Example: Operator + Overloading Using Friend Function

We will overload + to add two objects of class Complex.

‚úî Code Example
#include <iostream>
using namespace std;

class Complex {
private:
    int real, imag;

public:
    Complex(int r = 0, int i = 0) {
        real = r;
        imag = i;
    }

    // Declare friend function
    friend Complex operator + (Complex c1, Complex c2);

    void display() {
        cout << real << " + " << imag << "i" << endl;
    }
};

// Friend function definition
Complex operator + (Complex c1, Complex c2) {
    Complex temp;
    temp.real = c1.real + c2.real;
    temp.imag = c1.imag + c2.imag;
    return temp;
}

int main() {
    Complex a(5, 3);
    Complex b(2, 4);

    Complex c = a + b;   // Calls friend operator+

    c.display();
    return 0;
}

üì§ Output
7 + 7i

