express ‚Äì Express.js, often referred to simply as Express, is a minimal and flexible Node.js web application framework designed for building web applications and APIs. 
          It is a popular and widely used framework within the Node.js ecosystem, often considered the de facto standard for server-side development with Node.js. 
          In essence, Express.js simplifies and enhances the process of building server-side applications and APIs with Node.js by providing a structured and efficient way 
          to handle HTTP requests, manage routing, and implement various functionalities through its middleware system.

dotenv/config ‚Äì automatically loads .env file (containing secrets like MONGO_URI, JWT_SECRET, PORT).

cookie-parser ‚Äì allows server to read cookies (used for JWT tokens or session IDs).

cors ‚Äì enables cross-origin requests (important since frontend runs on a different port).

path ‚Äì helps resolve file paths safely across platforms.

1)authRoutes, 
2)userRoutes, 
3)chatRoutes 
‚Äì modular route handlers for authentication, user management, and chat operations.

************************* CORS Middleware ******************
Allows your React frontend (Vite on port 5173) to communicate with backend.
credentials: true lets cookies/JWT tokens be shared securely.


express.json() parses incoming JSON requests.

cookieParser() extracts cookies from client requests.


1Ô∏è‚É£ What is the role of cors() here?
Answer: It enables requests from a different origin (the frontend). Since the React app runs on a different port (5173), CORS allows the browser to make secure API calls 
          and include cookies/tokens.

2Ô∏è‚É£ Why is credentials: true important?
Answer: It lets browsers send authentication cookies (or JWT tokens) with cross-origin requests. Without it, the server can‚Äôt identify logged-in users.

5Ô∏è‚É£ What is the use of cookieParser()?
Answer: It parses cookies attached to client requests so they can be accessed via req.cookies. Useful for authentication tokens stored in cookies.

6Ô∏è‚É£ How are frontend routes handled in production?
Answer: All non-API routes (*) serve the index.html file from the React build folder, letting React Router handle client-side navigation.

7Ô∏è‚É£ What is path.resolve() doing here?
Answer: It returns the absolute path of the current directory (__dirname), which is necessary for serving static files correctly.



********************************************************** 1)authRoutes ******************************************
/signup ‚Üí Registers new users (usually stores hashed passwords, creates tokens).
/login ‚Üí Verifies credentials, issues authentication token or cookie.
/logout ‚Üí Clears session/cookie or invalidates token.
These routes are public (no authentication required).

Protected Routes
router.post("/onboarding", protectRoute, onboard);


protectRoute middleware runs first:
Checks if user is authenticated (usually by decoding JWT).
If valid, attaches user info to req.user.

Then calls onboard controller, which completes user setup (e.g., saving preferences, profile info).


Session Check Route
router.get("/me", protectRoute, (req, res) => {
  res.status(200).json({ success: true, user: req.user });
});

Returns the currently logged-in user‚Äôs data.

Useful for restoring sessions (e.g., after page refresh, to auto-login).


| Route                  | Auth Required | HTTP | Description                       |
| ---------------------- | ------------- | ---- | --------------------------------- |
| `/api/auth/signup`     | ‚ùå             | POST | Register new user                 |
| `/api/auth/login`      | ‚ùå             | POST | Log user in                       |
| `/api/auth/logout`     | ‚ùå             | POST | Log user out (clear cookie/token) |
| `/api/auth/onboarding` | ‚úÖ             | POST | Setup user profile after auth     |
| `/api/auth/me`         | ‚úÖ             | GET  | Check if token/session is valid   |



1Ô∏è‚É£ What is the role of protectRoute middleware?
Answer:
It checks whether a user is authenticated before allowing access to protected routes. Typically, it:
Reads JWT token from cookies or headers.
Verifies the token with JWT_SECRET.
Attaches decoded user info to req.user.
If verification fails ‚Üí returns 401 Unauthorized.

5Ô∏è‚É£ What does the logout route do internally?
Answer:
Usually clears the cookie storing JWT (using res.clearCookie("token")) or invalidates the token server-side (if stored in DB or cache).
This effectively ends the user‚Äôs session.

6Ô∏è‚É£ Why use POST for logout instead of GET?
Answer:
Logout changes the server‚Äôs state (removing a session/cookie).
POST is safer than GET (which should be idempotent and not alter state).




‚úÖ Interview Answer: Explain Your Project in Brief

‚ÄúMy project is a real-time video calling and language-learning social platform called Streamify Video Calls.
It allows users to connect with people worldwide, make friends, and communicate through chat and video calls.
On the backend, I built the system using Node.js, Express, MongoDB, and JWT authentication. The project is structured using the MVC pattern.

Key features I implemented:
1. User Authentication & Onboarding
Secure login and signup using JWT, password hashing with bcrypt,
Users complete onboarding with profile details, languages, and preferences.

2. Stream Video-Call Integration
I integrated Stream API (StreamChat) to generate tokens and upsert users into the Stream platform.
This allows us to enable real-time chat and video calling without managing WebRTC manually.

3. Friend System (Like Social Media)
I built a complete friend-management system:
- Send friend requests
- Accept requests
- Incoming & outgoing requests
- Friend list
- Recommended users (excluding current user & existing friends)

This uses two Mongoose models:
User
FriendRequest

4. Protected Routes & Middleware
All user-related APIs are protected using a custom auth middleware.
Middleware validates the JWT and injects the authenticated user into the request.

5. Clean and Scalable API Architecture
I separated everything into:
Routes
Controllers
Models
Stream utility (stream.js)

This makes the code modular and production-ready.

6. Database Management with MongoDB
Used Mongoose schemas with pre-save hooks (password hashing)
Used $addToSet, $nin, $ne queries for efficient friend recommendation and relationship management

üéØ Short and impressive version (if interviewer wants very brief)
‚ÄúMy project is a real-time video calling and social interaction platform.
Users can sign up, create profiles, send and accept friend requests, and join video calls using Stream API.
On the backend, I implemented secure authentication, friend management, and Stream token generation using Node.js, Express, MongoDB, and structured everything using the MVC pattern.‚Äù





üî∑ 1. Client ‚Üí Server ‚Üí Stream API Architecture
Frontend (React/Next.js)
      ‚Üì HTTP requests (Axios/Fetch)
Backend (Node.js + Express)
      ‚Üì
Controllers ‚Üí Services ‚Üí Database (MongoDB)
      ‚Üì
Stream API (for chat + video calls)


‚≠ê Database Schema Design : 1) User, 2) FriendRequest
üóÑÔ∏è Database Schema Diagram (High-Level)
Users
 ‚îú‚îÄ‚îÄ _id
 ‚îú‚îÄ‚îÄ fullName
 ‚îú‚îÄ‚îÄ email
 ‚îú‚îÄ‚îÄ password (hashed)
 ‚îú‚îÄ‚îÄ bio
 ‚îú‚îÄ‚îÄ profilePic
 ‚îú‚îÄ‚îÄ nativeLanguage
 ‚îú‚îÄ‚îÄ learningLanguage
 ‚îú‚îÄ‚îÄ location
 ‚îú‚îÄ‚îÄ isOnboarded
 ‚îî‚îÄ‚îÄ friends ‚Üí [User._id]

FriendRequests
 ‚îú‚îÄ‚îÄ sender ‚Üí User._id
 ‚îú‚îÄ‚îÄ recipient ‚Üí User._id
 ‚îî‚îÄ‚îÄ status ("pending" | "accepted")


‚≠ê 2. Challenge: Preventing Duplicate Friend Requests
Problem : Users were able to send the same friend request multiple times or even send a request to themselves.

What I did
Added validation to block:
- Self requests
- Requests to existing friends
- Duplicate pending requests

Used MongoDB query:

$or: [
  { sender: myId, recipient: recipientId },
  { sender: recipientId, recipient: myId }
]

Outcome : The friend request system became consistent, clean, and impossible to exploit.




‚≠ê 6. Challenge: Designing Friend Recommendation Logic
Problem => 
Recommended users should exclude:
- The logged-in user
- Already added friends
- Not-yet-onboarded users

What I did

Wrote MongoDB query using:
$ne, $nin, $and

Outcome : The recommendation feature became accurate and efficient.



‚úÖ Where does your project store chats between friends?
‚úÖ Your project does NOT store chats in your MongoDB database.
There is no Message model and no custom chat persistence in your backend.
But your project does store chats ‚Äî using Stream (GetStream) Chat API.

üî• Where are chats stored?
üëâ Chats are stored on Stream‚Äôs own servers (GetStream Cloud Infrastructure).

StreamChat is a managed real-time messaging platform, so your backend does NOT need to:
‚ùå create a message schema
‚ùå save messages to MongoDB
‚ùå manage chat channels manually

Instead, Stream handles:
‚úî chat history
‚úî channels
‚úî real-time messaging
‚úî user typing indicators
‚úî unread counts
‚úî message persistence
‚úî message search


üìå So the final answer for interview:
‚ÄúWhere are chats stored in your project?‚Äù
All chat messages and chat channels in my Streamify application are stored using the Stream Chat API (GetStream).
My backend only generates Stream user accounts and secure auth tokens.
Stream automatically manages message storage, channels, message history, real-time updates, and scalability on their cloud infrastructure.
So the chat data is not stored in MongoDB ‚Äî it is stored and managed entirely by Stream.‚Äù





üîÑ COMPLETE WORKFLOW OF FRIEND REQUEST SYSTEM

### üîπ Step 1: User Sends Friend Request
API: POST /api/users/friend-request/:id

Validations checked:
‚úî Cannot send request to yourself
‚úî Recipient must exist
‚úî Already friends? ‚Üí reject
‚úî Already a pending request both directions? ‚Üí reject

If valid ‚Üí create:
FriendRequest.create({
  sender: myId,
  recipient: recipientId,
  status: "pending"
});


### üîπ Step 2: User Receives Pending Requests
API: GET /api/users/friend-requests

Fetches:
incomingReqs = FriendRequest.find({
  recipient: req.user.id,
  status: "pending"
})

‚úî Populates sender profile
‚úî Used to show ‚ÄúAccept / Reject Request‚Äù UI


### üîπ Step 3: User Accepts Friend Request
API: PUT /api/users/friend-request/:id/accept

Flow:
1Ô∏è‚É£ Validate request exists
2Ô∏è‚É£ Check current user = recipient
3Ô∏è‚É£ Update request status ‚Üí "accepted"
4Ô∏è‚É£ Add EACH USER to the other's friend list:

await User.findByIdAndUpdate(senderId, {
  $addToSet: { friends: recipientId }
});

await User.findByIdAndUpdate(recipientId, {
  $addToSet: { friends: senderId }
});


### üîπ Step 4: Store Final Friends List
Once accepted, both users get:
"friends": [ "friendId1", "friendId2", ... ]

This is used in:
‚úî Chat system (show friends available for calls)
‚úî Recommended users (exclude existing friends)
‚úî UI sidebar friend list



‚úÖ Simple Explanation of How I Implement Video Calls

‚ÄúI added video calling to my project using Stream‚Äôs Video API.
Stream works on top of WebRTC ‚Äî which is the technology that actually sends video and audio between two people.
My backend does not handle video directly.
It only creates a Stream token for each user so they can securely join a call.
When a user wants to start or join a call, the frontend uses Stream‚Äôs SDK along with this token.
Stream then takes care of the complicated parts like:
- finding and connecting both users
- sharing network details between them
- managing the call room
After Stream finishes this setup, WebRTC ( web Real Time communication) automatically creates a direct peer-to-peer video connection between both users.
This allows smooth and high-quality video and audio communication.‚Äù




‚úÖ Improvements & New Features I Would Add

‚≠ê 5. Add User Blocking / Reporting
üî• Why? => Prevents harassment and spam.

üõ† How:
Add blockedUsers: [] array in User model.
Modify friend request endpoint to check: if (recipient.blockedUsers.includes(myId)) reject
Add a /block/:id route.


‚≠ê 6. Add Group Calls
üî• Why? => Expands platform usage ‚Üí group study, team meetings, group chat.

üõ† How:
Use Stream‚Äôs "Call Type: default".
Create group rooms with dynamic participant list.
Modify frontend UI to support multiple tiles (grid layout).


‚≠ê 7. Improve Friend Recommendation System
Reason: Right now your recommendation is simple:
‚û°Ô∏è ‚ÄúShow users who are not my friends and not me‚Äù.

How to Improve:
Add machine learning-based recommendations
Suggest users based on:
Same native/learning language
Same location
Common friends
Interests in bio



‚úÖ Why didn‚Äôt you use WebSockets?
üéØ Short Version (Perfect for Interviews)
‚ÄúWebSockets are good for real-time messaging, but they‚Äôre not optimized for audio/video streaming.
Since my project involved video calls, I used Stream API, which internally handles WebRTC, scalability, and security, saving development time and complexity.‚Äù

üí° Bonus Line (Very Impressive)
‚ÄúIf the project only required simple chat or notifications, WebSockets would be enough. But for real-time video communication at scale, 
a managed solution like Stream is more reliable.‚Äù




‚úÖ Interview Answer: Explain Your Project in Brief
‚ÄúConnectPro is a real-time chat and video calling platform designed for language exchange.
It allows users to connect with people worldwide, make friends, and communicate through chat and video calls.
On the frontend, I used React with Tailwind CSS.
On the backend, I built the system using Node.js, Express and MongoDB for data storage.
I implemented secure user authentication using JWT and bcrypt, along with profile onboarding.
For real-time chat and video calling, I integrated the Stream API to handle token generation and user management.
I also implemented a friend management system similar to social media platforms where users can send, receive, and accept friend requests.
// Friend recommendations are generated by filtering existing friends and pending requests efficiently using MongoDB queries.
All APIs are protected using custom authentication middleware.
The project is modular, scalable and responsive for different device size.‚Äù



üî¥ Challenges Faced in the Project
1. Real-time Communication Integration
Integrating real-time chat and video calling was challenging because handling WebRTC directly is complex.
To solve this, I integrated the Stream API, which required proper token generation, user synchronization, and secure backend handling.

2. Secure Authentication & Authorization
Implementing JWT-based authentication with protected routes was challenging, especially ensuring token validation across multiple APIs.
I solved this by creating a reusable authentication middleware that injects the authenticated user into every request.

3. Friend Request & Recommendation Logic
Designing the friend system was tricky due to multiple states like pending, accepted, outgoing, and incoming requests.
I used optimized MongoDB queries like $addToSet, $nin, and $ne to handle this efficiently.

4. Database Relationship Management
Maintaining clean relationships between users and friend requests without duplication required careful schema design and indexing.

5. Scalability & Clean Architecture
Ensuring the project stayed modular and scalable was challenging as features grew.
I addressed this by strictly following the MVC pattern and separating business logic into controllers and utilities.


üü¢ What Would You Improve If Given More Time?
1. Real-time Notifications
I would add WebSocket-based notifications for friend requests, acceptances, and missed calls.

2. Better Recommendation Algorithm
Improve friend recommendations using mutual friends, language similarity, and activity history instead of simple filtering.

3. Performance Optimization
Add Redis caching for frequently accessed data like friend lists and user profiles to reduce database load.

4. Advanced Security Features
Implement refresh tokens, rate limiting, and API request throttling for enhanced security.

5. Frontend Enhancements
Improve UI/UX with better call controls, reconnect logic, and mobile responsiveness.

6. Monitoring & Logging
Integrate logging and monitoring tools like Winston and Prometheus for better production observability.
