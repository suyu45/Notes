What is JavaScript?
JavaScript is a high-level, interpreted, dynamically typed programming language mainly used to create interactive and dynamic content on websites.
It runs primarily in the browser (using JavaScript engines like V8) and also on the server using environments like Node.js.

Common uses:
Form validation
Dynamic UI updates
API calls (AJAX / Fetch)
Frontend frameworks (React, Angular, Vue)
Backend development (Node.js)
Mobile & desktop apps


| Feature           | JavaScript                           | Java                                 |
| ----------------- | ------------------------------------ | ------------------------------------ |
| Language type     | Scripting language                   | Object-Oriented Programming language |
| Typing            | Dynamically typed                    | Statically typed                     |
| Compilation       | Interpreted / JIT compiled           | Compiled to bytecode                 |
| Platform          | Browser & Server (Node.js)           | JVM (Java Virtual Machine)           |
| Syntax            | Lightweight & flexible               | Verbose & strict                     |
| OOP               | Prototype-based                      | Class-based                          |
| Execution         | Single-threaded (event loop)         | Multi-threaded                       |
| Use cases         | Web development (frontend + backend) | Enterprise, Android, backend systems |
| File extension    | `.js`                                | `.java`                              |
| Memory management | Automatic (GC)                       | Automatic (GC)                       |


Key Differences Explained (Interview Friendly)

1. Typing

JavaScript determines variable type at runtime
let x = 10;
x = "hello";

Java requires type declaration at compile time
int x = 10;



Detailed Explanation (Easy to Understand)
Originally, JavaScript was considered an interpreted language, but modern JavaScript engines (like V8, SpiderMonkey, Chakra) use Just-In-Time (JIT) compilation.

Why Not Fully Compiled Like C/C++?
JavaScript is dynamically typed
Code can change at runtime


Why is JavaScript Single-Threaded?
Short interview answer:
ðŸ‘‰ JavaScript is single-threaded to keep the language simple, predictable, and safe when interacting with the DOM.

Detailed Explanation (Interview-Ready)
1. To Avoid DOM Conflicts (Main Reason â­)
JavaScript was designed mainly for browsers, where it interacts with the DOM (Document Object Model).

If multiple threads modified the DOM at the same time:
Race conditions would occur
UI could break or become inconsistent
Complex locking mechanisms would be required

ðŸ‘‰ Single thread ensures only one task modifies the DOM at a time.



1. var, let, const â€“ Overview
| Feature       | `var`                            | `let`         | `const`       |
| ------------- | -------------------------------- | ------------- | ------------- |
| Scope         | Function-scoped                  | Block-scoped  | Block-scoped  |
| Hoisting      | Yes (initialized as `undefined`) | Yes (TDZ)     | Yes (TDZ)     |
| Reassignment  | Allowed                          | Allowed       | âŒ Not allowed |
| Redeclaration | Allowed                          | âŒ Not allowed | âŒ Not allowed |
| Introduced in | ES5                              | ES6           | ES6           |

2. Scope
var â€“ Function Scope
function test() {
  var x = 10;
}
console.log(x); // âŒ Error (outside function)

But inside blocks:
if (true) {
  var y = 20;
}
console.log(y); // âœ… 20


let â€“ Block Scope
if (true) {
  let a = 10;
}
console.log(a); // âŒ Error


const â€“ Block Scope
if (true) {
  const b = 30;
}
console.log(b); // âŒ Error


3. Hoisting â­ (Very Important)
var Hoisting
console.log(x); // undefined
var x = 10;

Reason:
var x is hoisted and initialized as undefined.

let & const Hoisting (TDZ) Temporal Dead Zone
console.log(y); // âŒ ReferenceError
let y = 10;

Variables are hoisted But not initialized

Exist in Temporal Dead Zone (TDZ) until declaration


4. Reassignment
var
var x = 10;
x = 20; // âœ… allowed

let
let y = 10;
y = 20; // âœ… allowed

const
const z = 10;
z = 20; // âŒ Error

5. const with Objects & Arrays âš ï¸ (Tricky Question)
const obj = { name: "JS" };
obj.name = "JavaScript"; // âœ… allowed
obj = {}; // âŒ Error

ðŸ‘‰ const prevents reassignment, not mutation.

6. Redeclaration
var a = 10;
var a = 20; // âœ… allowed

let b = 10;
let b = 20; // âŒ Error

const c = 10;
const c = 20; // âŒ Error

7. Best Practices (Interview Tip ðŸ’¡)
Use const by default
Use let when reassignment is needed
Avoid var (unless legacy code)

One-Line Interview Answer â­
var is function-scoped and hoisted with undefined, while let and const are block-scoped, hoisted in the Temporal Dead Zone, and const does not allow reassignment.

Common Interview Output Question
console.log(a); âŒ ReferenceError (TDZ)
let a = 10;


1. What is Temporal Dead Zone?
Definition (simple):
ðŸ‘‰ TDZ is the time between the start of a block and the actual declaration of a let or const variable, during which the variable exists but cannot be accessed.

Accessing it in this period causes a ReferenceError.

2. Why TDZ Exists? (Very Important â­)
TDZ was introduced with let and const to:
Prevent using variables before declaration
Catch bugs early
Enforce better coding practices
Make code behavior more predictable


1. What is Hoisting?
Definition:
ðŸ‘‰ Hoisting is JavaScriptâ€™s behavior of moving variable and function declarations to the top of their scope during the memory creation phase.
Happens before code execution
Affects variables and functions

| Feature         | Hoisting                         | TDZ                    |
| --------------- | -------------------------------- | ---------------------- |
| What it is      | JS mechanism                     | Safety restriction     |
| When it happens | Memory creation phase            | Runtime period         |
| Applies to      | `var`, `let`, `const`, functions | `let` and `const` only |
| Error thrown    | Usually none                     | ReferenceError         |
| Purpose         | Allocate memory                  | Prevent early access   |


4. Hoisting Behavior by Keyword

var
console.log(a); // undefined
var a = 10;

Hoisted
Initialized as undefined
âŒ No TDZ


let
console.log(b); // ReferenceError
let b = 10;

Hoisted
âŒ Not initialized
âœ… TDZ applies


5. Visual Timeline (Important ðŸ”¥)
var
Hoisted â†’ initialized (undefined) â†’ assigned value

let / const
Hoisted â†’ TDZ â†’ initialized â†’ usable


10. One-Line Interview Answer â­
Hoisting allocates memory for variables before execution, while TDZ is a restriction period for let and const where accessing them before initialization causes an error.

11. Interview Tip ðŸ’¡
If asked: â€œAre let and const hoisted?â€
Say: Yes, they are hoisted but kept in the Temporal Dead Zone until initialized.



2. Primitive Data Types â­ (Most Asked)
Primitive types store single values and are immutable.
List of Primitive Data Types: string, number, boolean, undefined, null, symbol, bigint

3. Non-Primitive Data Types
Non-primitive types store collections of values and are mutable.
object, array, function, date, ( map and set (internally objects) )

| Feature    | Primitive    | Non-Primitive             |
| ---------- | ------------ | ------------------------- |
| Stores     | Single value | Multiple / complex values |
| Stored by  | Value        | Reference                 |
| Mutable    | âŒ No         | âœ… Yes                     |
| Memory     | Stack        | Heap                      |
| Comparison | By value     | By reference              |

3ï¸âƒ£ boolean : Represents logical values.

let isLoggedIn = true;
Falsy values: false, 0, "", null, undefined, NaN

4ï¸âƒ£ undefined : A variable declared but not assigned a value.

let a;
console.log(a); // undefined

Default value assigned by JS


5ï¸âƒ£ null â­ (Very Tricky) : Represents intentional absence of value.

let data = null;

âš ï¸ Interview trap:
typeof null; // "object" (bug in JS)


6ï¸âƒ£ symbol (ES6) : Represents unique and immutable values.

let id = Symbol("id");
let id2 = Symbol("id");
id === id2; // false

Used for:
Unique object keys
Avoiding naming conflicts


7ï¸âƒ£ bigint (ES2020)
Used for very large integers beyond Number limit.

let big = 123456789012345678901234567890n;

Ends with n
Cannot mix with number

10n + 20n; // âœ…
10n + 20;  // âŒ Error


6. Non-Primitive Examples
Object
let user = { name: "Suyog", age: 21 };

Array
let arr = [1, 2, 3];

Function
function greet() {}


7. Value vs Reference Example (Important â­)
let a = 10;
let b = a;
b = 20;

console.log(a); // 10

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 5;

console.log(obj1.x); // 5

8. Common Interview Questions & Traps
Q1: typeof null? ðŸ‘‰ "object"

Q2: Is JavaScript statically typed? ðŸ‘‰ âŒ No, dynamically typed

Q3: Are strings mutable? ðŸ‘‰ âŒ No

Q4: Are arrays primitive? ðŸ‘‰ âŒ No, they are objects

9. One-Line Interview Answer â­
JavaScript has primitive data types that store immutable values by value, and non-primitive types that store mutable data by reference.


1. What are Truthy & Falsy?
Falsy â†’ values that behave like false in a boolean context
Truthy â†’ everything else that behaves like true
JavaScript performs implicit boolean conversion when needed.

JavaScript has 8 falsy values including false, 0, "", null, undefined, NaN, -0, and 0n.
ðŸ‘‰ If a value is not in this list, it is truthy.


1. What is Type Coercion?

ðŸ‘‰ Type coercion is JavaScriptâ€™s automatic or manual conversion of one data type into another.

There are two types:
Implicit coercion (automatic)
Explicit coercion (manual)

2. Implicit Type Coercion (Automatic) â­
JavaScript automatically converts types during operations.

2.1 String Coercion
+ operator
"5" + 2;     // "52"
5 + "2";     // "52"
ðŸ‘‰ If either operand is a string, result is a string.

2.2 Number Coercion
-, *, /
"5" - 2;   // 3
"5" * 2;   // 10
"10" / 2;  // 5
Strings are converted to numbers.


3. Explicit Type Coercion (Manual) âœ…
You explicitly convert types using functions.

3.1 To String
String(10);     // "10"
(10).toString(); // "10"

3.2 To Number
Number("10");   // 10
parseInt("10"); // 10
parseFloat("10.5"); // 10.5


5. == vs === (Must Mention)
| Operator | Checks       | Coercion |
| -------- | ------------ | -------- |
| `==`     | Value        | âœ… Yes    |
| `===`    | Value + Type | âŒ No     |

null == undefined; // true


2. null vs undefined (VERY COMMON QUESTION â­)
ðŸ”¹ undefined
Variable is declared but not assigned
Automatically assigned by JavaScript
let a; console.log(a); // undefined

ðŸ”¹ null
Represents intentional absence of value
Explicitly assigned by developer
let b = null;

| Feature       | `null`                  | `undefined`        |
| ------------- | ----------------------- | ------------------ |
| Meaning       | Intentional empty value | Value not assigned |
| Assigned by   | Developer               | JavaScript         |
| Type          | `object` (JS bug)       | `undefined`        |
| Default value | âŒ No                    | âœ… Yes              |

typeof null;      // "object" âŒ (bug)
typeof undefined; // "undefined"


2. Strict Mode ("use strict") â­ (VERY IMPORTANT)
What is Strict Mode?
ðŸ‘‰ Strict Mode is a restricted version of JavaScript that:
Catches common coding mistakes
Prevents unsafe actions
Makes code more secure & predictable

How to Enable Strict Mode
Entire Script

"use strict";
x = 10; // âŒ Error



1. What is Variable Shadowing?
Variable shadowing occurs when a variable declared in an inner scope has the same name as a variable in an outer scope. 
The inner variable â€œshadowsâ€ (overrides) the outer one within its scope.

2. Basic Example

let x = 100; // Outer scope
function test() {
  let x = 50; // Inner scope shadows outer x
  console.log(x); // 50
}
test();
console.log(x); // 100 (outer x unaffected)



******* Hoisting Example (Declaration)
sayHello(); // âœ… Works because function declarations are hoisted with body
function sayHello() {
  console.log("Hi!");
}


*********** Function Expression **********
greet(); // âŒ ReferenceError
const greet = function() {
  console.log("Hello!");
};

7. One-Line Interview Answers â­
Function Declaration : A function declaration is fully hoisted, has a name, and can be called before it is defined.
Function Expression : A function expression is assigned to a variable, not hoisted fully, and cannot be called before the assignment.



1. What is an Arrow Function?
Arrow functions are shorter syntax for writing functions, introduced in ES6, and they do not have their own this, arguments, super, or new.target.

// Traditional function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b;
const square = x => x * x;
const sum = (a, b) => {
  const result = a + b;
  return result;
};



1. What is a Callback Function?
A callback function is a function passed as an argument to another function, which is then executed inside the outer function.
Callbacks are used for:
Asynchronous operations (AJAX, setTimeout, Promises)
Event handling
Functional programming (map, filter, forEach)

Example: Greeting User with Callback
// This is the callback function
function greetUser(name) {
  console.log("Hello, " + name + "!");
}

// This is the function that accepts a callback
function processUser(callback) {
  const userName = "Suyog";
  callback(userName); // Call the callback function
}

// Call the function and pass the callback
processUser(greetUser);






1. Rest Operator ...
The rest operator collects all remaining elements or arguments into an array.
Used in function parameters or destructuring
Must be last parameter in a function

1.1 Rest in Function Parameters
function sum(...numbers) {
  console.log(numbers);        // array of all arguments
  return numbers.reduce((a,b) => a + b, 0);
}

console.log(sum(1,2,3,4)); // 10

...numbers collects all arguments into an array
Works with any number of arguments


1.2 Rest in Array Destructuring
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first);  // 1
console.log(second); // 2
console.log(rest);   // [3,4,5]

1.3 Rest in Object Destructuring
const person = { name: "Suyog", age: 21, city: "Latur" };
const { name, ...others } = person;
console.log(name);   // "Suyog"
console.log(others); // { age: 21, city: "Latur" }


2. Spread Operator ...
The spread operator expands an array or object into individual elements.
Used in function calls, array literals, object literals

2.1 Spread in Arrays
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combined = [...arr1, ...arr2];
console.log(combined); // [1,2,3,4,5,6]

2.2 Spread in Function Calls
const nums = [1, 2, 3];
console.log(Math.max(...nums)); // 3

Expands array elements into individual arguments

2.3 Spread in Objects
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const combinedObj = { ...obj1, ...obj2 };
console.log(combinedObj); // { a:1, b:2, c:3, d:4 }


5. One-Line Interview Answers â­
Rest Operator => The rest operator collects multiple elements or arguments into a single array.
Spread Operator => The spread operator expands an array or object into individual elements.



1. What is this in JavaScript?
The this keyword refers to the object that is currently executing the function, or the context in which a function is called.

2. this in Global Context
console.log(this);

In browser â†’ window object
In Node.js â†’ {} (module.exports)
In strict mode â†’ undefined



1. What is a Closure?
A closure is a function that remembers and has access to its lexical scope, even when the function is executed outside that scope.
Every function in JavaScript forms a closure naturally
Closures allow data privacy and function factories

2. Basic Example
function outer() {
  let count = 0; // local variable in outer function

  function inner() {
    count++;
    console.log(count);
  }

  return inner; // returning inner function
}

const counter = outer(); // outer() executed, returns inner
counter(); // 1
counter(); // 2
counter(); // 3


âœ… Explanation:
inner forms a closure over count
count persists between calls even though outer has finished execution



1. What is Asynchronous JavaScript?
Asynchronous JavaScript allows the program to perform long-running tasks without blocking the main thread, letting other code run while waiting for tasks 
like API calls, timers, or file operations to complete.

JS is single-threaded, so async operations use callbacks, promises, or async/await to handle delayed tasks.

2. Synchronous vs Asynchronous

2.1 Synchronous Example
console.log("Start");
console.log("Process");
console.log("End");

Output:
Start
Process
End

Each statement executes one after another


2.2 Asynchronous Example
console.log("Start");
setTimeout(() => {
  console.log("Inside Timeout");
}, 2000);
console.log("End");

Output:
Start
End
Inside Timeout

setTimeout is asynchronous â†’ non-blocking
JS continues executing the next lines


4. Common Ways to Handle Async in JS

4.1 Callbacks
function fetchData(callback) {
  setTimeout(() => {
    callback("Data received");
  }, 1000);
}

fetchData((data) => console.log(data));

Oldest method, can lead to callback hell


4.2 Promises
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Data received"), 1000);
});

fetchData
  .then((data) => console.log(data))
  .catch((err) => console.log(err));

Cleaner than callbacks
resolve â†’ success, reject â†’ error


4.3 Async / Await
function getData() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("Data received"), 1000);
  });
}

async function fetchData() {
  const data = await getData();
  console.log(data);
}

fetchData();


Makes async code look synchronous
Must use async keyword with await



1. Definition
Synchronous JavaScript
Code executes line by line, one statement after another.
Each operation blocks the next until it completes.

Asynchronous JavaScript
Code executes without blocking, allowing long-running tasks (like API calls or timers) to run in the background while other code continues.
