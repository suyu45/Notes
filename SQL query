‚úÖ EXISTS in SQL
EXISTS is a Boolean operator in SQL that checks whether a subquery returns at least one row.
If the subquery returns 1 or more rows ‚Üí EXISTS = TRUE
If the subquery returns 0 rows ‚Üí EXISTS = FALSE
It is commonly used with correlated subqueries.

‚ú® Key Points
EXISTS does not return data ‚Äî it only checks if rows exist.
The subquery usually references the outer query (correlated subquery).
SQL stops searching as soon as it finds one matching row ‚Üí fast performance.


‚úÖ Example 1: Find employees who belong to at least one department
SELECT e.emp_id, e.name
FROM employees e
WHERE EXISTS (
    SELECT 1
    FROM departments d
    WHERE d.dept_id = e.dept_id
);

‚úî Why SELECT 1?

EXISTS ignores selected columns.
It only checks if any row is returned.


‚úÖ Example 2: Find customers who have placed at least one order
SELECT c.customer_id, c.name
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
);

‚úî Returns only customers who have at least one order.


‚úÖ Example 3: NOT EXISTS

Find customers with no orders:

SELECT c.customer_id, c.name
FROM customers c
WHERE NOT EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
);


üî• EXISTS vs IN (Quick Difference)
| Feature            | EXISTS                 | IN                             |
| ------------------ | ---------------------- | ------------------------------ |
| Works better with  | Large subquery results | Small subquery results         |
| Checks             | Row existence          | Matching values                |
| Behavior with NULL | Safe                   | Can give wrong/missing results |


üéØ When to use EXISTS?
Use EXISTS when:
- You are checking existence of related rows.
- You need a correlated check.
- The subquery returns large data.
- You want the query to stop early after the first match.


*************************************************************************************************************************


CREATE TABLE logs (
    id INT PRIMARY KEY,
    message VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

Whenever a row is inserted ‚Üí created_at automatically stores system time.


1. CURRENT_TIMESTAMP
SELECT CURRENT_TIMESTAMP; ‚û° Returns current date + time

2. NOW()
SELECT NOW(); ‚û° Same as CURRENT_TIMESTAMP


üìÜ 2. Date & Time Functions (Most Important for SQL Interviews)

‚≠ê 1. DATE() => Extracts only the date part.
SELECT DATE('2025-02-21 10:35:20'); 
-- Output: 2025-02-21


‚≠ê 2. TIME() => Extracts only the time part.
SELECT TIME('2025-02-21 10:35:20');


‚≠ê 3. DAY(), MONTH(), YEAR()
SELECT YEAR(NOW());   -- 2025
SELECT MONTH(NOW());  -- 2
SELECT DAY(NOW());    -- 21


‚≠ê 4. DATE_ADD() => Add days/months/years.
SELECT DATE_ADD('2025-02-21', INTERVAL 7 DAY);


‚≠ê 5. DATE_SUB() => Subtract dates.
SELECT DATE_SUB('2025-02-21', INTERVAL 1 MONTH);


‚≠ê 6. DATEDIFF() => Difference in days.
SELECT DATEDIFF('2025-03-01','2025-02-21');


‚≠ê 7. TIMESTAMPDIFF() => Difference in minutes/hours/days.
SELECT TIMESTAMPDIFF(HOUR, '2025-02-20 05:00:00', '2025-02-21 10:00:00');


‚≠ê 8. DAYNAME(), MONTHNAME()
SELECT DAYNAME('2025-02-21');   -- Friday
SELECT MONTHNAME('2025-02-21'); -- February


üîç 3. EXTRACT() Function
EXTRACT() is used to extract specific parts from a date/time.

Syntax: EXTRACT(unit FROM date_value)

Examples:
‚úî Extract Year
SELECT EXTRACT(YEAR FROM '2025-02-21 10:30:00');

‚úî Extract Month
SELECT EXTRACT(MONTH FROM NOW());

‚úî Extract Day
SELECT EXTRACT(DAY FROM '2025-02-21');

‚úî Extract Hour / Minute / Second
SELECT EXTRACT(HOUR FROM '2025-02-21 10:30:00');
SELECT EXTRACT(MINUTE FROM '2025-02-21 10:30:00');

‚úî Extract Quarter
SELECT EXTRACT(QUARTER FROM '2025-02-21');
-- Output: 1

‚úî Extract Week
SELECT EXTRACT(WEEK FROM '2025-02-21');


üß† Most Asked Interview Examples
üî∏ Find employees who joined this year:
SELECT * FROM employees
WHERE YEAR(join_date) = YEAR(CURDATE());

üî∏ Find records created in last 7 days:
SELECT * FROM orders
WHERE order_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY);

üî∏ Group orders by month:
SELECT MONTHNAME(order_date) AS Month, COUNT(*) 
FROM orders
GROUP BY Month;


‚≠ê Short Interview Definition
Timestamp : A TIMESTAMP stores both date + time and can automatically capture the current system time when inserting or updating rows.
Extract : EXTRACT() pulls a specific part of a date/time like YEAR, MONTH, DAY, HOUR.
Date & Time Functions : Functions like NOW(), DATE(), CURDATE(), DATE_ADD(), DATEDIFF() help manipulate and calculate dates and times.



*******************************************************************************************************************************************

‚úÖ What is a Window Function?
A Window Function performs calculations across a set of rows related to the current row,
without grouping or collapsing them into a single row (unlike GROUP BY).

It uses the OVER() clause and ‚Äúwindows‚Äù of rows.

üìå Useful for: Running totals, Ranking, Moving averages, Partition-wise calculations, Percentages, Previous & next row values

‚≠ê Syntax
function_name(...) OVER (
    PARTITION BY column
    ORDER BY column
)

üéØ Types of Window Functions
1) Aggregate Window Functions ‚Üí SUM(), AVG(), COUNT(), MIN(), MAX()
2) Ranking Functions ‚Üí ROW_NUMBER(), RANK(), DENSE_RANK()
3) Value Functions ‚Üí LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE()
4) Analytic Functions ‚Üí NTILE(), CUME_DIST(), PERCENT_RANK()


‚≠ê Aggregate Window Functions in SQL
Aggregate window functions allow you to apply aggregate functions (like SUM, AVG, MIN, MAX, COUNT) without collapsing rows.
üëâ In normal aggregates (GROUP BY), rows collapse into groups.
üëâ In window aggregates, all rows remain, and aggregate values are shown alongside each row.

üìå Input Table: sales
| name  | region | sales |
| ----- | ------ | ----- |
| Aadi  | North  | 1000  |
| Ravi  | North  | 800   |
| Neha  | South  | 1200  |
| Kiran | South  | 1100  |

üìå Query (Both SUM() with and without PARTITION)
SELECT
    name,
    region,
    sales,

    -- SUM() WITH PARTITION (Total sales per region)
    SUM(sales) OVER (
        PARTITION BY region
    ) AS region_total,

    -- SUM() WITHOUT PARTITION (Running total of whole table)
    SUM(sales) OVER (
        ORDER BY sales DESC
    ) AS running_total

FROM sales;

üìå Output Table
| name  | region | sales | region_total | running_total |
| ----- | ------ | ----- | ------------ | ------------- |
| Neha  | South  | 1200  | 2300         | 1200          |
| Kiran | South  | 1100  | 2300         | 2300          |
| Aadi  | North  | 1000  | 1800         | 3300          |
| Ravi  | North  | 800   | 1800         | 4100          |


************* ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING => start to end *********************
SUM(sales) OVER ( ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS region_total_unbounded
adds all rows 



‚≠ê Value Window Functions
‚úÖ LAG()
‚úÖ LEAD()
‚úÖ FIRST_VALUE()
‚úÖ LAST_VALUE()


üìå Input Table: daily_sales
| day | sales |
| --- | ----- |
| Mon | 100   |
| Tue | 150   |
| Wed | 120   |
| Thu | 180   |
| Fri | 160   |

üìå SQL Query Demonstrating All 4 Functions
SELECT
    day,
    sales,
    LAG(sales, 1) OVER (ORDER BY day) AS prev_day_sales,
    LEAD(sales, 1) OVER (ORDER BY day) AS next_day_sales,
    FIRST_VALUE(sales) OVER (ORDER BY day) AS first_day_sales,
    LAST_VALUE(sales) OVER (
        ORDER BY day
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_day_sales

FROM daily_sales;

üìå Output Explained
| day | sales | prev_day_sales | next_day_sales | first_day_sales | last_day_sales |
| --- | ----- | -------------- | -------------- | --------------- | -------------- |
| Mon | 100   | NULL           | 150            | 100             | 160            |
| Tue | 150   | 100            | 120            | 100             | 160            |
| Wed | 120   | 150            | 180            | 100             | 160            |
| Thu | 180   | 120            | 160            | 100             | 160            |
| Fri | 160   | 180            | NULL           | 100             | 160            |




‚≠ê Ranking Functions
‚úÖ ROW_NUMBER() in SQL
ROW_NUMBER() is a window function that assigns a unique sequential number to each row in a result set based on a specified ordering.

‚úÖ Basic Syntax
ROW_NUMBER() OVER (ORDER BY column_name) 

‚úî Key Points
Starts from 1 for each partition.
Requires an ORDER BY inside OVER().
Even if two rows have the same values, ROW_NUMBER() never assigns duplicate numbers.



‚úÖ RANK() in SQL
RANK() is a window function that assigns a rank to each row based on an ordering.
Unlike ROW_NUMBER(), rows with equal values get the same rank, and the next rank is skipped.

üß† Key Points
| Feature          | Behavior                                |
| ---------------- | --------------------------------------- |
| Duplicate values | Same rank                               |
| Rank gap         | YES (skips next rank)                   |
| Order required   | YES (inside OVER())                     |
| Partitioning     | Optional (restarts rank for each group) |

‚úÖ Basic Syntax
RANK() OVER (ORDER BY column_name)




‚úÖ DENSE_RANK() in SQL
DENSE_RANK() is a window function that assigns ranks to rows based on ordering.
Similar to RANK(), rows with the same value get the same rank, but‚Ä¶

üëâ It does NOT skip the next rank.
üëâ Ranks are continuous (dense).

üß† Key Points
| Feature          | Behavior                  |
| ---------------- | ------------------------- |
| Duplicate values | Same rank                 |
| Rank gap         | ‚ùå NO (continuous ranking) |
| Order required   | YES                       |
| Partitioning     | Optional                  |

‚≠ê Basic Syntax
DENSE_RANK() OVER (ORDER BY column_name)




| Function         | Tie Handling                           | Gap in Rank?       | Uniqueness      | Best Used For                     |
| ---------------- | -------------------------------------- | ------------------ | --------------- | --------------------------------- |
| **ROW_NUMBER()** | No ties ‚Üí every row gets unique number | ‚ùå No              | ‚úî Always unique | Pagination, removing duplicates   |
| **RANK()**       | Same values ‚Üí same rank                | ‚úî YES (skips rank) | ‚ùå Not unique   | Leaderboards, competition ranking |
| **DENSE_RANK()** | Same values ‚Üí same rank                | ‚ùå NO (no skipping)| ‚ùå Not unique   | Categories ranking without gaps   |


üß© Sample Data
| name  | marks |
| ----- | ----- |
| Aadi  | 95    |
| Ravi  | 90    |
| Neha  | 90    |
| Kiran | 85    |

‚≠ê 2. Comparison with Result Table
SQL Query:
SELECT 
    name,
    marks,
    ROW_NUMBER() OVER (ORDER BY marks DESC) AS row_num,
    RANK() OVER (ORDER BY marks DESC) AS rank_pos,
    DENSE_RANK() OVER (ORDER BY marks DESC) AS dense_rank_pos
FROM students;

‚≠ê 3. Output (Most Expected in Interviews)
| name  | marks | ROW_NUMBER | RANK | DENSE_RANK |
| ----- | ----- | ---------- | ---- | ---------- |
| Aadi  | 95    | 1          | 1    | 1          |
| Ravi  | 90    | 2          | 2    | 2          |
| Neha  | 90    | 3          | 2    | 2          |
| Kiran | 85    | 4          | 4    | 3          |

üéØ 4. Explanation in One Line Each
‚úî ROW_NUMBER() => Gives each row a unique sequence number, even if values are same.
‚úî RANK() => Same values share same rank, but next rank is skipped.
‚úî DENSE_RANK() => Same values share rank, but next rank is not skipped (dense).




‚úÖ INPUT TABLE: sales
| name  | region | sales |
| ----- | ------ | ----- |
| Aadi  | North  | 1000  |
| Ravi  | North  | 1000  |
| Neha  | North  | 1200  |
| Kiran | South  | 1100  |
| Suyog | South  | 1200  |
| Ram   | South  | 1200  |
| Rohan | South  | 1300  |

‚úÖ QUERY
SELECT
    name,
    region,
    sales,
    DENSE_RANK() OVER(
        PARTITION BY region
        ORDER BY sales DESC
    ) AS dense_rank,
    RANK() OVER(
        PARTITION BY region
        ORDER BY sales DESC
    ) AS rank,
    ROW_NUMBER() OVER(
        PARTITION BY region
        ORDER BY sales DESC
    ) AS row_number
FROM sales;

‚úÖ OUTPUT TABLE
North Region
| name | region | sales | dense_rank | rank | row_number |
| ---- | ------ | ----- | ---------- | ---- | ---------- |
| Neha | North  | 1200  | 1          | 1    | 1          |
| Aadi | North  | 1000  | 2          | 2    | 2          |
| Ravi | North  | 1000  | 2          | 2    | 3          |

South Region
| name  | region | sales | dense_rank | rank | row_number |
| ----- | ------ | ----- | ---------- | ---- | ---------- |
| Rohan | South  | 1300  | 1          | 1    | 1          |
| Suyog | South  | 1200  | 2          | 2    | 2          |
| Ram   | South  | 1200  | 2          | 2    | 3          |
| Kiran | South  | 1100  | 3          | 3    | 4          |




üìå Interview-Ready Definition
Window functions are SQL functions that perform calculations across a specific set of rows (window) relative to the current row, without collapsing rows like GROUP BY. 
They use the OVER() clause with ORDER BY and PARTITION BY.



************************************************************************************************************************************************************************

‚≠ê SQL CASE Statement / CASE Expression
CASE is used to apply conditional logic inside a SQL query.
It works like an if-else or switch statement.
It returns a value based on conditions.

‚úÖ Two Types of CASE in SQL

‚úî 1. Simple CASE
Compares a column to multiple values (like switch-case).

CASE column
    WHEN value1 THEN result1
    WHEN value2 THEN result2
    ELSE default_result
END


‚úî 2. Searched CASE
Uses logical conditions (like if-elseif-else).

CASE 
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ELSE default_result
END


‚≠ê Example 1: Simple CASE
SELECT
    order_id,
    status,
    CASE status
        WHEN 'P' THEN 'Pending'
        WHEN 'S' THEN 'Shipped'
        WHEN 'C' THEN 'Cancelled'
        ELSE 'Unknown'
    END AS full_status
FROM orders;


‚≠ê Example 2: Searched CASE (IF-ELSE type)
SELECT
    name,
    salary,
    CASE 
        WHEN salary < 40000 THEN 'Low'
        WHEN salary BETWEEN 40000 AND 70000 THEN 'Medium'
        WHEN salary > 70000 THEN 'High'
        ELSE 'Not Defined'
    END AS salary_category
FROM employees;



‚≠ê Example 4: CASE inside Aggregation
SELECT
    SUM(CASE WHEN marks >= 40 THEN 1 ELSE 0 END) AS passed,
    SUM(CASE WHEN marks < 40 THEN 1 ELSE 0 END) AS failed
FROM students;


********************************************************************************************************************************


‚≠ê SQL WITH Clause / CTE (Common Table Expression)
A CTE (Common Table Expression) is a temporary named result set that exists only for the duration of a single SQL query.
You create it using the WITH clause.
It behaves like a temporary table or a subquery, but is more readable and reusable.

‚úÖ Syntax of a CTE
WITH cte_name AS (
    SELECT ...
)
SELECT * FROM cte_name;


‚≠ê Example 1: Basic CTE
WITH avg_sal AS (
    SELECT AVG(salary) AS avg_salary FROM employees
)
SELECT 
    name,
    salary
FROM employees, avg_sal
WHERE salary > avg_sal.avg_salary;

‚úî Cleaner
‚úî Easy to understand
‚úî Reusable



‚≠ê Example 2: Multiple CTEs (Comma Separated)
WITH high_salary AS (
    SELECT * FROM employees WHERE salary > 50000
),
low_salary AS (
    SELECT * FROM employees WHERE salary <= 50000
)
SELECT * FROM high_salary
UNION ALL
SELECT * FROM low_salary;
